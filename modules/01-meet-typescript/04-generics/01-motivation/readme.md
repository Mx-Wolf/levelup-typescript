# Обобщенное программирование
## Теория типов
Если вы счастливый обладатель сокровенного математического знания, вы без труда распознаете, что источник магической силы typescript исходит из теории типов. Именно оперируя понятием типа компиляютору удается выяснить какие операции со значениями вашей переменной можно выполнять, а какие нет. Ниже мы обсудим экспресс-курс теории типов.

Для наших целей тип это вывеска на коробке. На вывеске написано название типа, а еще, что важнее, написан список операций, которые допустимы в отношении типа. Это наше правило! Если правила выполняются, то в коробке лежат *все* возможные значения этого типа. 

* В коробке с названием *number* лежат числа, но не все а только те которые определены стандратом IEEE-754 (кроме Infinity, NaN)
* В коробке с названием *string* лежат строки. Их там бесконечно много.
* и т.д.

**Важно**, что с любым элементом из коробки можно проделать **все** действия, указанные на вывеске.

Возьмем кробку побольше и поместим туда содержимое наших *string* и *number*. Взболтаем и перемешаем.

Элемент, который мы можем вытащить из этой большой коробки может быть числом или строкой. Теперь вопрос. Какой список операций мы должны написать на вывеске, чтобы не нарушать правило. Этот список должен содержит операции, которые можно выполнить и над строкой и над числом.  

Чтобы составить вывеску для нашей большой коробки мы сократили список оперкций. Вычеркнули из него те опреации, которые можно выполнить над строкой, но нельзя выполнить над числом. Мы, так же вычеркнули те операции, которые можно выполнить над числом, но нельзя выполнить над строкой.

Коробка стала "шире" а список операций стал "короче". Кстати, операция, которую мы проделали над списками операций для *string* и для *number* называется "пересечением". 

**Внимание!** Чтобы описать тип, к значениям которого можно применять операции из пересечения операций других типов, Typescript применяет синтаксис `string | number`

Можно представить другую ситуацию.  Мы решили собрать в отдельную коробку такие элементы над которыми можно выполнить **все** операции из списка *number* и **все** операции из списка *string*. Так чтобы наш список-результат стал длиннее. Можно предположить, что сама коробка станет *поменьше*.

Мы перебираем все возможные строки и отбираем стреди них те, которые способны учавствовать во всех операциях с числами. Возможно мы ничего не найдем. 

Потом перебираем все числа и откладываем те, которые готовы участвовать во всех операциях со строками. В результате мы снова ничего не найдем. Тем не менее коробку мы можем организовать. Пустую коробку. 

**Внимание** Если мы хотим потребовать от typescript такой новый тип, значения которого могут быть использованы во всех операциях нескольких других типов - используем синтаксис `string & number`. 

* читайте `type n = a | b` как: новый тип `n` такой, что список операций над его значениями является пересечением списка операций `a` и списка операций `b`.
* читайте `type n = a & b` как: новый тип `n` такой, что список операций над любым значением этого типа является объдинением список операций из `a` и списка операций из `b`.

Помните, при сложении чисел есть одно, специальное число 0. такое, что его можно добавлять к любому другому числу, но ничего не поменяется. При умножении есть другое специальное число 1. Эти числа еще называют - единичными элементами. У typescript есть две специальные коробки - их названия - unknown и  never.

тип unknown работает единичным элементом для операции объединения
```typescript
  T & unknown => T
```
и тим never работает единичным элементом для операции пересечения
```typescript
  T | never => T
```
![Система типов typescript]('assents/type-system.png')

Самая большая коробка - unknown. Она же имеет и самый короткий список операци - пустой. 
