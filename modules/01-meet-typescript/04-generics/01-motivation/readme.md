# Обобщенное программирование

## Теория типов

Для наших целей тип это вывеска на коробке. На вывеске написано название типа, а еще, что важнее, написан список операций, которые допустимы в отношении типа.

* В коробке с названием *number* лежат числа, но не все а только те которые определены стандартом IEEE-754 (кроме Infinity, NaN)
* В коробке с названием *string* лежат строки. Их там бесконечно много.
* и т.д.

**Важно**, что с любым элементом из коробки можно проделать **все** действия, указанные на вывеске. Это наше правило!

## Операции с типами

Возьмем коробку побольше и поместим туда содержимое наших *string* и *number*. Взболтаем и перемешаем.

Элемент, который мы можем вытащить из этой большой коробки может быть числом или строкой. Теперь вопрос. Какой список операций мы должны написать на вывеске, чтобы не нарушать правило. Этот список должен содержит операции, которые можно выполнить и над строкой и над числом.  

Чтобы составить правильную табличку для нашей большой коробки мы сократили список операций. Вычеркнули из него те операции, которые можно выполнить над строкой, но нельзя выполнить над числом. Мы, так же вычеркнули те операции, которые можно выполнить над числом, но нельзя выполнить над строкой.

Коробка стала "шире" а список операций стал "короче". Кстати, операция, которую мы проделали над списками операций для *string* и для *number* называется "пересечением".

**Внимание!** Чтобы описать тип, к значениям которого можно применять операции из пересечения операций других типов, Typescript применяет синтаксис `string | number`

Можно представить другую ситуацию.  Мы решили собрать в отдельную коробку такие элементы над которыми можно выполнить **все** операции из списка *number* и **все** операции из списка *string*. Так чтобы наш список-результат стал длиннее.

Мы перебираем все возможные строки и отбираем среди них те, которые способны участвовать во всех операциях с числами. Возможно мы ничего не найдем.  Можно предположить, что сама коробка станет *поменьше*.

Потом перебираем все числа и откладываем те, которые готовы участвовать во всех операциях со строками. В результате мы снова ничего не найдем. Тем не менее коробку мы можем организовать. Пустую коробку.

**Внимание** Если мы хотим потребовать от typescript такой новый тип, значения которого могут быть использованы во всех операциях нескольких других типов - используем синтаксис `string & number`.

* читайте `type n = a | b` как: новый тип `n` такой, что список операций над его значениями является пересечением списка операций `a` и списка операций `b`.
* читайте `type n = a & b` как: новый тип `n` такой, что список операций над любым значением этого типа является объединением списка операций из `a` и списка операций из `b`.

## Единичные элементы системы типов

Помните, при сложении чисел есть одно, специальное число 0. такое, что его можно добавлять к любому другому числу, но ничего не поменяется. При умножении есть другое специальное число 1. Эти числа еще называют - единичными элементами. У typescript есть две специальные коробки - их названия - unknown и  never.

тип unknown работает единичным элементом для операции объединения

```typescript
  T & unknown => T
```

Коробка с именем unknown самая широкая, но зато на ней пустой список операций. Ничего мы не может сделать с этим типом. Ну разве что `typeof` выяснить.

Тип never работает единичным элементом для операции пересечения

```typescript
  T | never => T
```

Коробка с этим типом самая узкая - в ней нет никаких элементов. Немудрено, что с любым элементом (из нуля) элементов можно совершать любые операции. Такая уж математика.

![Система типов typescript]('assents/type-system.png')

## Встречаем обобщенное программирование

Когда typescript гарантирует нам что со значениями того или иного типа можно делать оговоренные действия мы можем создавать процедуры, которые заранее не определяют конкретный тип.

```typescript
// функция вернет первый элемент массива. 
// Его тип и значение будет известно потом. 
// сейчас важно, что набор элементов это массив
function firstItem<T>(array:T[]):T{
  if(array.length>0){
    return array[0];
  }
  throw new Error("empty array");
}
```

Имея описание такой функции мы можем опереться на компилятор и поручить ему убедиться, что после получения элементы мы сможем использовать значения по назначению

```typescript
const array1 = [42,73];
const theAnswer = firstItem(array1);
// typeof theArray === "number";
// мы может использовать значение безопасно
Math.abs(theAnswer); //ok
theAnswer.split(","); //Property 'split' does not exist on type 'number'.(2339)

```
