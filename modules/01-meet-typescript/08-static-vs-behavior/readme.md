# Место typescript в борьбе за качество

## Статический анализ и его ограничения

Компилятор typescript прикладывает максимум усилий, чтобы обеспечить согласованность различных частей вашего api. Анализ производится на основе определений типов и операций над ними статически. Другими словами обнаружение дефектов в программе производится без ее запуска.

Во многих случах этот метод позволяет значительно улучшить качество создаваемого кода. Он выявляет места, которые, вполне возможно, приведут к неверной работе программы. Дополнительно, статический анализ позволяет создавать единообразный код, который легче читать и сопровождать в последствии.

Однако статический анализ имеет свои ограничения. Будет ли работать следующий код?

```typescript
const x = Math.random() < 0.5 ? 0 : 1;

console.log(42 / x);
```

[Попробовать в песочнице](https://www.typescriptlang.org/play?ssl=3&ssc=21&pln=1&pc=1#code/MYewdgzgLgBAHjAvDAsgQygCwHQCc1gAmIAtgBQCUMAPDAAzYCsMA-PTAFwwCMA3AFD9QkEABsAptlEgA5mQAsAJhgB6eBV5A)

**Важно!** Поставьте like, если у вас программа заработала. Шутка.

Статический анализ не понимает намерений программиста.

```typescript
const rectangleArea = (width: number, height: number): number => width + height;
```

Для typescript [этот фрагмент](https://www.typescriptlang.org/play?#code/MYewdgzgLgBATgU2FAhmA5gGwQQUSmAXhgAoB3ASwBMoALALhjAFcBbAIwTgBoZaEK6WlEYsOXAJSi2nOEQB8MSjVowA1HwFCoAbiA) является вполне приличным.

В частности, typescript не может контролировать обращение за пределы массива или к несуществующим свойствам.

```tsx
const arr:number[] =[];
const obj:Record<string, number> = {};

const elementOfArray = arr[0]; //typescript считает, что переменная имеет тип number, но ее значение undefined
const propertyValue = obj["property"];// такая же история
```

[Проверьте в песочнице](https://www.typescriptlang.org/play?ssl=5&ssc=58&pln=1&pc=1#code/MYewdgzgLgBAhgJwQLjAVwLYCMCmCDaAujALxEDcAUKJLCFgFbIBKOoCAJgDzQICWYAOYAaGOmx4AfKRgBvAL5Vq4aDBwAbHBhxgoAeQBmAQSRwAnjMQEADIXIwA9A6hmADjgjB+r2IEEQQOIggBwggEIggAwggKwgwaL+wYB8IDCA-CDhgAIg4YA8IOGAvCCZoYDyIDCBGZEwwYEJYpi4CKKZ8eHhMIDsIDn+WYENaGAcOAYCOBzKtDCuCCDuCC4AanDqaDgy9Az4AEQjY3guy3ZOJaGAXCB5MIBsIA2BvnHJgblAA)

Проконтролировать выход за пределы массива и другие краевые ситуации в работе алгоритма - задача разработчика, и было бы полезно иметь автоматические инструменты, которые позволили бы убедиться, что *динамические* намерения разработчика соблюдаются так же как и намерения по использованию типов. Но это выходит за рамки возможностей typescript.

Подчеркнем, что у статического анализа есть свои преимущества. Этот метод действительно позволяет зафиксировать намерения разработчика с точки зрения типов и контролировать их соблюдения. Но надо что-то делать с контролем поведения программы.

## Фиксация поведения

Для фиксации поведения удобно использовать unit-tests. Это те самые места, где разработчику следует *записывать комментарии к коду*. Действительно, комментарии написанные в тексте программы в виде `/**/` или `//` устаревают после первого же рефакторинга, в то время как unit-test проверяет фактическое поведение функции. Кроме того, unit-test может быть озаглавлен понятными словами.

```javascript
describe('алгоритм вычисления площади прямоугольника',()=>{
  it('получает 0 для нулевой высоты',()=>{
    expect(rectangleArea(42,0)).toBe(0);
  });
  it('завершается аварийно для отрицательной высоты',()=>{
    expect(()=>rectangleArea(42,-1)).toThrow();
  });
});
```

Если, во время очередного рефакторинга, разработчик разрешит вычислять отрицательную площадь, что, вполне возможно для векторной математики, например, ему придется изменить и unit test. А это, в свою очередь зафиксирует новое поведение.

Использование unit тестирования дополняет работу компилятора typescript в борьбе за качество продукта.

## Качество и время

Использование unit тестирование удлиняет цикл разработки в начале. Это же можно сказать и о typescript. Но использование и того и другого метода оказывается преимуществом в процессе дальнейшего жизненного цикла продукта.
 