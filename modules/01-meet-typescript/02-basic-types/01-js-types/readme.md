# Работа с примитивными типами
## Система типов javascript
Все типы данных, которые вы можете различать в javascript остаются в вашем распоряжении и при работе с typescript. Прежде всего это примитивные типы

* boolean
* number
* string
* undefined

Все свойства, особенности и операции, характерные для этих типов в typescript идентичны тем что вам известно о них из javascript. Но есть нюансы.

```javascript
let buffer = '';
const answer = 42;
buffer = 42;
```
Выражение `buffer = 42` совершенно законное для javascript вызывает ошибку `Type 'number' is not assignable to type 'string'.(2322)`. Дело в том, что typescript рассматривая эти строки неявно добавляет определения типов, настолько хорошо, насколь он может угадать. Для компилятора следующие три строки эквивалентны предыдущим

```typescript
let buffer:string = ''; //догадался по типу из инициализирующего значения
const answer:number = 42;// тоже догадался 
buffer = 42; // а предвидеть этого не смог!!!
```
В этом случае становется более очевидно поведение комплятора.

Как видно из описания ошибки, typescript считает, что переменная буфер предназначена только для работы со строками. В течение этого курса мы обсудим, как объяснить компилятору наши намерения хранить в буфере и строки и числа. Но уже из этого примера видно, что typescript требует от разработчика более внимательного и точного выражения намерений. 

Забегая вперед, и чтобы удовлетворить любопытство, посмотрим, как можно объяснить компилятору наши намерения.

```typescript
let buffer: string|number = '';
const answer = 42;
buffer = answer;
```
Добавив аннотацию типа `: string|number` (читается как буффер типа строка или число), мы объяснили компилятору, что в переменной buffer мы планируем хранить не только строки, но и числа.

Сделаем вывод, пока мы не смешиваем примитивные типы внутри одной пременной, typescript ведет себя практически идентично javascript.

## Знакомство с типами функции
Рассмотрим пример использования функции в typescript
```typescript
document.addEventListener('click',function(ev){console.log(ev);});
```
На первый взгляд функция `function(ev){console.log(ev);}` не выглядит так уж подозрительно, но это только благодаря умению typescript догадываться и подставлять аннотации типов неявным образом. Что написано в этом исходном тексте, можно представить так.
```typescript
document.addEventListener<"click">('click',function (this:Document, ev:MouseEvent):void {console.log(ev)});
```
Каждый элемент этого выражения мы разберем в свое время. Попробуйте положить это выражение в песочницу и посмотреть, какой код будет создан на javascript.

Сейчас важно запомнить, что обявляя функцию мы должне заявить о намерении использовать в качестве аргументов значения определенных типов. 

Для описания различных вариантов функций в typescript ввели дополнительные специальные типы.

* void
* never

тип void предназначен для описания результата функции, которая ничего не возвращает. Если вы знакомы с C/C++, Java, то вам понятно использование этого типа. 

```typescript
function log(message:string):void{
    console.log(message);
}
```
В отличии от void тип never подсказывает комплиятору и нам с вами, что функция никогда не возвращается. Вот два примера, которые позволяют почувствовать разницу между void и never.

```typescript
const readMessage = ()=>'';
const processMessage = (mes:string)=>{};

function eventLoop():never{
    while(true){
        const m = readMessage();
        processMessage(m);
    }
}

function alwaysThrow():never{
    throw new Error('Not implemented yet');
}
``` 
## Структуры типов. Интерфейсы, пстевдонимы
Данные в программах typescript можно группировать по смыслу и назначению в стуктурые типы.
```typescript
const hero = {
    givenName: 'Илья',
    fathersName: 'Ильич',
    familyName: 'Обломов',
};
```
Для typescript hero не только имеет значение, но еще имеет и тип. 

**Важно** описание этого типа существует только для typescript и после окончания трансляции в javascript полностью исчезает. 

Однако мы можем пользоваться знанием этого типа в других частях программы. Для того чтобы объявить еще одну переменную, содержащую такие же поля, а главное заставить typescript проверить, что мы не ошиблись мы можем запомнить описание типа и обозначить это описание отдельным идентификатором.

```typescript
type Hero = typeof hero;
const supporting: Hero = {
    givenName: 'Андрей',
    fathersName: 'Иванович',
    familyName: 'Штольц',
};
```
Проделайте эксперимент в песочнице. Скопируйте определение константы hero и типа Hero. Затем начинет выписывать инициалзицию константы supporting. Вы увидите, как редактор начинает вас поддерживать и подсказывать.

Обратите внимание! Мы можем обозначить описание типа несколько раз разными словами. Все эти описания исчезнут во время работы программы, а во время компиляции эти значения идентичны друг-другу.

```typescript
type Hero = typeof hero;
type FullName = typeof hero;
type AnotherAlias = Hero;
type LongDescription = {
    givenName: string,
    familyName: string,
    fathersName: string,
}
```

Важно! структурные типы не отличимы в typescript, если их поля попарно эквивалентны или имеют одинаковые примитивные типы. Порядок следования полей не существеннный.
