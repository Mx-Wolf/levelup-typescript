# Сходство и различия в возможностях  TypeScript  и модульного тестирования

## Компилятор TypeScript держит оборону на одном фланге

В борьбе за качество ПО, статический анализ, который выполняет TypeScript позволяет создать определенный уровень уверенности в качестве результата. Компилятор предупредит, если вы попытаетесь выяснить номер телефона у значения типа прямоугольник. Но этого недостаточно. Вы не можете рассказать компилятору, что оператор `throw new Error()`, который вы вставили в код представляет "договорное" поведение. 

```typescript
const dictionary:Record<string,string> = {}
export function translate(term: string){
  const result = dictionary[term];
  if(typeof result === "undefined"){
    throw new Error(`term not found ${term}`);
  }
  return result;
}
export function initialize(settings:Record<string,string>){
  dictionary = settings;
}
```

Другим вариантом реализации процедуры поиска по словарю мог быть возврат исходного термина. Возможно, при развитии программы, однажды вы решить, что этот вариант лучше - UI не ломается. То что термин будет на чужом языке, так это не существенно. Действительно, ведь все знают большинство терминов и без перевода.

```typescript
let dictionary:Record<string,string> = {}
export function translate(term: string){
  const result = dictionary[term];
  if(typeof result === "undefined"){
    return term;
  }
  return result;
}
export function initialize(settings:Record<string,string>){
  dictionary = settings;
}
```

Насколько безопасно произвести такую модификацию? А что если именно обработчик исключения ставил термин в очередь заданий переводчику?

## Модульное тестирование спешит на помощь

Для того, чтобы убедиться, что изменения, аналогичные второму примеру, не сломают вашу систему надо посмотреть реакцию других частей. Желательно это делать автоматически при помощи "железного" компьютера и без участия невнимательного человека.

В работе вы можете столкнуться с множеством систем, облегчающих модульное тестирование. React, в частности, использует jest.  В нашем проекте, мы используем `chai` + `mocha`

Для того, чтобы в будущем не забыть о "договорном" поведении функции мы бы сделали в отдельном модуле набор проверок.

```typescript
import {translate, initialize} from './translate-algo.js'
describe('поведение переводчика терминов translate',()=>{
  it('находит строку по термину',()=>{
    initialize({'один':'uno'})
    expect(translate('один')).to.be('uno');
  });
  it('завершается аварийно для неизвестных терминов',()=>{
    initialize({});
    expect(()=>translate('нет такого слова')).to.throw);
  })
})
```

Такой модульный тест обнаружит изменение в поведении функции translate, до того как вы развернете обновление на площадке заказчика. Вы сможете тщательно проверить ваши намерения и изменить их. Возможно, изменив "договорное" поведение в модульном тесте.

## А что на других фронтах

Следует сказать, что архитектурой и модульным тестированием история не ограничивается. У вас все еще остаются неприкрытыми фланги интеграции с другими системами, нагрузки в час пик и другие.

Важно понимать, что TypeScript добросовестно выполняет свои функции в своей зоне ответственности и использовать его по назначению.
