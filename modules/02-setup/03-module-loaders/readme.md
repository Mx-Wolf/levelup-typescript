# О загрузке и генерации модулей

## Генерация модулей

Typescript поддерживает и поощряет деление кодовой базы на модули. У вас есть возможность проинструктировать `tsc` для генерации модулей различных форматов.

Допустимые варианты такие:

* none
* commonjs
* amd
* umd
* system
* es6/es2015
* es2020
* es2022
* esnext
* node12
* nodenext

это значение указывается в файле tsconfig.json

```json
{
  "compilerOptions": {
    "module": "ES2020"
  }
}
```

Хотя названия допустимых опций говорят сами за себя вы можете почувствовать желание увидеть результат компиляции воочию. Легче всего это сделать в [песочнице](https://www.typescriptlang.org/play).

Добавьте в левой части, в редакторе typescript, выражение

```typescript
export const circumference = (radus:number)=>Math.PI*2*radus;
```

Выберите меню `TS Config` и верхней части найдите настройку опции модуль. Она представляет из себя выпадающий список. Если вы будете менять выбранную опцию, текст javascript в правой части будет меняться в реальном времени. Если вы застали эпоху UMD, то вы увидите знакомые выражения. Typescript теперь их делает за нас.

Кстати, попробуйте стереть ключевое слово `export`. Вся магия с генерацией бойлерплайт модулей пропадает. Как вы думаете, почему это происходит?

Значение настройки module лучше указывать явно. Но на всякий случай следует помнить, что по умолчанию его значение `CommonJS` для целевой версии javascript **ES3** or **ES5**, но оно меняется на `ES6/ES2015` для других целевых версий.

Настройка CommonJS, по видимому, еще какое-то время останется наиболее часто встречающейся для проектов node.

## Поиск модулей

Связанной с target является настройка `moduleResolution`. Эта настройка определяет стратегию поиска файлов с модулями по их имени в инструкциях import и require. Ее следует использовать явно.

Допустимые варианты значения этой опции

* classic
* node
* node12
* nodenext

`classic` исторически сохранена из версии typescript 1.0 и, вероятно, вам не придется ее использовать. `node12` и `nodenext` предназначены для поддержки ECMAScript модулей на стороне nodejs.

Сами стратегии не являются чем-то очень сложным. Когда наступит время и их рассмотрим более подробно. Для вступления отметим, что файл ищется относительно текущего, если имя файла в кавычках начинается с `./` или `../`

```typescript
import {fun} from "./module-fun.js"
```

и поиск ведется в `node_modules`, если имя файла не начинается с точки.

```typescript
import {service} from "well-known-lib"
```

## Целевая версия Javascript

Typescript в состоянии создать код Javascript для разных уровней обратной совместимости. Желаемая целевая версия может быть указана в настройках в файле `tsconfig.json`.

```json
{
  "compilerOptions": {
    "target": "ES2020"
  }
}
```

Допустимые варианты настройки этой опции

* ES3,
* ES5,
* ES6,
* ES2015,..., ES2021
* ESNext

В зависимости от значения настройки tsc будет не только создавать исходный код javascript соответствующего уровня, но и подключать соответствующие библиотеки с определениями API.

## Несколько слов о .gitignore

Применительно к контексту разработки на typescript файлы javascript являются производными и поэтому их не нужно отправлять в систему контроля версий.

Распространенной практикой является создание конфигурации, когда файлы .ts и производные .js располагаются в разных директориях. Этого можно достичь указанием в файле tsconfig.json целевой директории.

```json
{
  "compilerOptions": {
    "outDir": "./js"
  }
}
```

В такой конфигурации все производные файлы (.js, .d.ts, js.map) будут создаваться относительно этой директории `./js`, которую и следует включить в `.gitignore`


## Параметры командной строки и запуск в среде node

В контексте nodejs следует нацеливать компилятор на создание модулей в формате commonjs. Это важно помнить для обеспечения возможности запуска модульных тестов.

Вы можете обеспечить работу вашего компилятора таким образом, что при запуске `npm run start` будут создаваться модули es6, а при запуске модульных тестов `npm run test` будет использовать `commonjs`.




