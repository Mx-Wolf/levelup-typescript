# Использование "переменных" в операциях над типами

Ключевое слово `infer` может встречаться в конструкции условного типа, должно быть использовано в рамках выражения *extends* и предназначено для указания компилятору *как назвать* тип в момент вычисления типов (т.е. в редакторе) если условие выполнено.

```typescript
type ResultType<T> = T extends (...args:unknown[])=> infer R? R: never;

declare function getName ():string;
declare function getAnswer():42;

type StringResult = ResultType<typeof getName>;
//type StringResult = string
type NarrowNumberResult = ResultType<typeof getAnswer>;
//type NarrowNumberResult = 42
type NotCallable = ResultType<true>;
//type NotCallable = never
```

В первой строке примера слово infer можно читать как: *уважаемый компилятор, если при использовании обобщенного типа ResultType тип-переменная (т.е. значение в **T**) будет удовлетворять условию, т.е. будет функцией, то для целей дальнейших вычислений назови тип результата функции буквой **R***. Это и видно в приведенных примерах.

Кстати, такой обобщенный тип, похожий на ResultType уже приготовлен и готов к использованию в typescript "прямо из коробки".

Некоторые часто попадающиеся случаи использования infer мы предложим вам в качестве дополнительных вопросов к этому разделу.

## Полезные условные типы

Много вопросов из области определения типов встает перед разработчиком во время написания кода. Иногда возникает желание, чтобы typescript догадывался о каких-то типах самостоятельно. Такие желания попадают в  "todo" к разработчикам typescript на github. Удивительно, что огромная часть из них может быть решена без изменений в компиляторе, с помощью условных типов.

Разработчики даже включили в поставку полтора десятка решенных задач в виде utility types. Вы будете их использовать часто. Приведем список наиболее часто встречающихся типов.

* Partial&lt;Type> - делает новый структурный тип у которого все ключи исходного типа **Type** делаются необязательными

* Required&lt;Type> - делает новый структурный тип у которого все ключи исходного типа **Type** делаются обязательными

* Readonly&lt;Type> - делает новый структурный тип у которого все ключи исходного типа **Type** делаются доступными только для чтения

* Record&lt;Keys, Type> - создает новый индексируемый тип ключом значений которого являются значения типа **Keys** и который может хранить элементы типа **Type**

* Pick&lt;Type, Keys> - делает новый тип, содержащий только часть ключей (обозначенных **Keys**) из исходного типа.

* Omit&lt;Type, Keys> - делает новый тип, похожий на **Type** но в котором отсутствуют ключи **Keys**

* Exclude&lt;Type, ExcludedUnion> - делает новый тип такой, что в **type** не остается тех типов, которые перечислены в **ExcludedUnion**

Полный список удобных вспомогательных типов постоянно пополняется. Актуальную версию этого списка можно найти [на официальном сайте](https://www.typescriptlang.org/docs/handbook/utility-types.html)
