# Использование "переменных" в операциях над типами

Ключевое слово `infer` может встречаться в конструкции условного типа и предназначено для указания компилятору *как назвать* тип в момент вычисления типов (т.е. в редакторе) если условие выполнено.

```typescript
type ResultType<T> = T extends (...args:unknown[])=> infer R? R: never;

declare function getName ():string;
declare function getAnswer():42;

type StringResult = ResultType<typeof getName>;
//type StringResult = string
type NarrowNumberResult = ResultType<typeof getAnswer>;
//type NarrowNumberResult = 42
type NotCallable = ResultType<true>;
//type NotCallable = never
```

В первой строке примера слово infer можно читать как: *уважаемый компилятор, если при использовании обобщенного типа ResultType тип-переменная (т.е. значение в **T**) будет удовлетворять условию, т.е. будет функцией, то для целей дальнейших вычислений назови тип результата функции буквой **R***. Это и видно в приведенных примерах.

Кстати, такой обобщенный тип, похожий на ResultType уже приготовлен и готов к использованию в typescript "прямо из коробки".

## Полезные условные типы

Много вопросов из области определения типов встает перед разработчиком во время написания кода. Иногда возникает желание, чтобы typescript догадывался о каких-то типах самостоятельно. Такие желания попадают в спиcок "todo" к разработчикам typescript на github. Удивительно, что огромная часть из них может быть решена без изменений в компиляторе, с помощью условных типов.

Разработчики даже включили в поставку полтора десятка решенных задач в виде utility types.


