# Функции и сигнатуры

## Как описать функцию

Для программ на javascript функции являются основным строительным материалом. Typescript предоставляет разработчику дополнительные возможности, но функции остаются важной частью системы. Поэтому следует уметь выразить намерения использования функций в разных обстоятельствах. Привычное для javascript определение функции следует дополнять указанием ожидаемых типов аргументов и возвращаемого значения.

## Явная аннотация типов

Когда вы явно укажите все типы возможных значений, компилятор будет их использовать как для анализа внутри функции, так и в коде, вызывающем эту функцию.

```typescript
function exampleAction():void {console.log('еще элемент найден');};
function exampleAdapter(inValue:number):string {return `${inValue}`;}
function exampleReducer(state:number, action: number):number {return state+action;}
```

При описании функции `exampleAction` разработчик объяснил компилятору, что функция не ожидает никаких параметров, и не возвращает никакого значения. Тип `void` указывает на то, что функция вызывающий код не должен ожидать от функции какого-то результата.

При описании функции `exampleAdapter` разработчик объяснил компилятору, что для штатной работы пере вызовом в функцию надо передать параметр, содержащий числовое значение. Компилятор будет следить за этим во время анализа.

Описание этой функции одновременно сообщает компилятору (и другим пользователям) что в результате нормального завершения функция вернет результат строкового типа.

Из описания третьей функции `exampleReducer` мы делаем вывод, что для нормальной работы в функцию надо передать два числовых аргумента, а результат будет числом.

## Неявный вывод о типе результата функции

Во многих случаях, компилятор достаточно сообразителен, чтобы выяснить тип возвращаемого значения самостоятельно. Поэтому следующий вариант эквивалентен предыдущему.

```typescript
function exampleAction() {console.log('еще элемент найден');};
function exampleAdapter(inValue:number) {return `${inValue}`;}
function exampleReducer(state:number, action: number) {return state+action;}
```

Разглядывая текст функций в примере вы легко можете выяснить значения каких типов они возвращают. Компилятор действует так же. Кроме того, он запоминает свои догадки и использует их в других местах программы так, как будто описание было сделано с явным указанием типа результата. В этом смысле описания функций в этом и в предыдущем разделе эквивалентны.
 
## Вывод о типах параметров функции по контексту

Если определение функции появляется в контексте, то TypeScript в состоянии выяснить и типы аргументов.

```typescript
[1,2,3].forEach(function exampleAction(){console.log('еще элемент найден')});
const stringArray = [1,2,3].map(function exampleAdapter(inValue){return `${inValue}`;});
const sum = [1,2,3].reduce(function exampleReducer(state,action){return state+action},0);
```

В примере выше мы снова определили три функции, но на этот раз типы параметров и типы аргументов компилятор выяснил самостоятельно, по контексту использования.

## Функциональный (вызываемый) тип

Вы можете обозначить что переменная должна содержать функцию и может быть вызвана используя синтаксис, с виду похожий на стрелочную функцию `(...)=>...`. В следующем примере это `()=>boolean`;

```typescript
const myFuncVar: ()=>boolean = ()=>true;
```

Этот код транслируется в javascript предсказуемым образом. Описание типа изымается из текста.

```javascript
const myFuncVar = () => true;
```

Описание типа `()=>boolean` подсказывает компилятору, что функция не ожидает аргументов и возвращает значение типа boolean. Компилятор использует эту информацию для статического анализа программы. Компилятор проинформирует вас, если функция используется ненадлежащим образом.

Следующие выражения вызывают ошибку во время компиляции

```typescript
const message:string = myFuncVar();//Type 'boolean' is not assignable to type 'string'.
const flag:boolean = myFuncVar("test"); //Expected 0 arguments, but got 1.
```

Описанию типа функции можно назначить псевдоним.

```typescript
type UsefulService = ()=>boolean;
const myFuncVar:UsefulService = ()=>true;
```

## Сигнатура функции в структурном типе

В Javascript функции являются полноценными объектами, к ним можно добавлять свойства. Typescript предусматривает специальный синтаксис, позволяющий разработчику объявить намерение иметь значение, которое можно вызвать `()`, но у которого есть и другие поля. Если мы планируем иметь объект - функцию - у которой дополнительно есть свойство `description` мы воспользуемся следующим описанием.

```typescript
type DescribedFunction = {
    ():boolean;
    description: string;
}
```

тогда мы можем использовать договоренность для наших бизнес-потребностей. 

```typescript
function logExecution(fn:DescribedFunction){
    try{
        fn();
    }
    catch(ex){
        console.log(ex,fn.description)
    }
}
```


