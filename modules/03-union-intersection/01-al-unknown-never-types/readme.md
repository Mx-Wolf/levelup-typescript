# Вертикаль во Вселенной типов, верхний и нижний типы

## Теория типов

Для наших целей тип — это вывеска на коробке. На вывеске написано название типа, а внутри коробки лежат элементы — все возможные значения типа.

- В коробке с названием *number* лежат значения, которые определены стандартом IEEE-754 (кроме Infinity, NaN).
- В коробке с названием *string* лежат строки. Их там бесконечно много.
- В коробке boolean — два элемента.
- И так далее.

## Операции с типами, объединение

Возьмём коробку побольше, объединим в ней содержимое *string* и *number* и затем перемешаем. Элемент, который мы достанем из коробки, может быть числом или строкой. То есть коробка стала «шире», но чтобы поработать с каким-либо значением, сначала приходится уточнять, что нам попалось на этот раз: число или строка.

**Внимание!** Чтобы описать объединение нескольких типов,  TypeScript  применяет оператор `|`. Синтаксис: `string | number`.

Чтобы объяснить намерение использовать в качестве индекса базы данных строковые или числовые значения, мы можем определить тип:

```ts
type PrimaryKey = string | number;
```

Часто можно встретить задачу, в контексте которой мы можем получить значение либо функцию для получения этого значения. Тип такого аргумента — тоже объединение. Объединение типа «функция» и типа «строка». 

Вот один из возможных примеров:

```ts
type HomePathSettings = string | (()=> string)
const resolvePath = (settings: HomePathSettings)=> typeof settings === 'function'?settings():settings;
```

## Операции с типами. Пересечение

Можно представить другую ситуацию. Нам нужны значения, которые одновременно находятся в двух или нескольких коробках. Множество таких значений — пересечение исходных множеств доступных значений. Подумайте, значением переменной flyingDutchman будут не все жители Нидерландов, а только Летучие голландцы.

```typescript
type Flying = {
    fly():void,
};
type Fish = {
  swim():void,
};
type Saucer = {
    holdJam():void;
}
type Dutchman = {
    moveToAmsterdam():void;
}

declare const flyingFish: Flying & Fish;
declare const flyingSaucer: Flying & Saucer;
declare const flyingDutchman: Flying & Dutchman;

flyingFish.fly();
flyingSaucer.fly();
flyingDutchman.moveToAmsterdam();//
flyingDutchman.fly();
```

**Внимание** Если мы хотим потребовать от TypeScript такой новый тип, значения которого одновременно являются значениями нескольких других, мы используем синтаксис `string & number`.

Читаем вслух:

- Декларацию `type n = a | b` читаем как: новый тип, значения которого являются либо значениями типа `a`, либо значениями типа `b`.
- Декларацию `type n = a & b` читаем как: новый тип `n` такой, что любое значение этого типа является одновременно значением и типа `a`, и типа `b`.

Как бы вы прочитали?

```typescript
type n = (string | number) & string;
```

## Порядок во Вселенной типов

Мы уже говорили, что компилятор может сравнивать типы. Для двух типов может случиться так, что один расширяет другой. Выше мы составляли тип `string | number`, он шире, чем отдельно `string` или отдельно `number`. Если продолжать наводить порядок среди всего разнообразия типов, найдётся ли тип, шире которого ничего нет? А как насчёт самого узкого типа, уже которого не бывает? Можем ли мы построить что-то вроде оси координат?

```text
самый узкий < пошире < ... < ещё шире < ... < самый широкий
```

Оказывается, что-то подобное можно построить.

## Единичные элементы системы типов

Помните, при сложении чисел есть специальное число 0? Его можно добавлять к любому другому числу, но «ничего не поменяется». При умножении есть другое специальное число — 1. Эти числа называют единичными элементами относительно операции сложения и операции умножения. 

У TypeScript есть две специальные коробки: unknown и  never. Тип unknown работает единичным элементом для операции пересечения:

```typescript
  T & unknown ~> T
```

Коробка с именем unknown самая широкая, но зато на ней пустой список операций. Всё, что мы можем сделать с этим типом — выяснить `typeof`.

Тип never работает единичным элементом для операции объединения:

```typescript
  T | never ~> T
```

Коробка с этим типом самая узкая, в ней нет элементов. Неудивительно, что с любым элементом (из нуля элементов) можно совершать любые операции. Такая уж математика.

![Система типов typescript](assets/type-system.png)

В следующем разделе мы рассмотрим специализацию примитивных типов. Да, оказывается и `boolean` можно специализировать, коробку с boolean сузить.
