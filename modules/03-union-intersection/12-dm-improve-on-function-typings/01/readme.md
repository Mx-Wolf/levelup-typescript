# Специализация результата

Давайте понаблюдаем за функциями.

```ts
type KnownLanguageName = 'Sanskrit'|'Latin';
declare const getWord: (language: KnownLanguageName)=> string;
declare const detectLanguage: (word: string)=>KnownLanguageName;
```

Мы можем заметить, что функция `getWord` может вернуть в качестве значения слово, в том числе и слово Sanskrit и Latin. Но интереснее другое. Там где мы можем использовать функцию `getWord`, скажем в качестве колбэка, мы может применить и использовать и функцию `detectLanguage`. Но не наоборот.

А еще заметьте, что параметру `word` можно присвоить любое значение, если его можно присвоить параметру `language`.

В TypeScript функции обладают этим интересным не симметричным свойством. Они "взаимозаменяемы" **наоборот** относительно взаимозаменяемости их параметров. Такое поведение системы типов называют _контра-вариация_.

В отношении же результата функции действует правило - _ко-вариации_: Если вместо одного типа функции можно использовать другой тип функции, то и результат ведет себя так же - вместо результата первого типа функции можно использовать результат второго типа функций.

![co- contra- variance](../assets/co-contra-variance.drawio.png)

Как же быть, если нам нужно получить из функции специализированный тип данны? Нужно использовать перегрузку функций.

Есть однако нюанс. в JavaScript нет перегруженных функций... В этой демонстрации мы рассмотрим "наилучшее" приближение к использованию перегруженных функций.

## Задача

Мы определяем функцию-посредника - middleware - которая будет добавлять имя css-класса к списку классов HTMLElement-а.

## Проблема в интерфейсе функции

При использовании различных HTML элементов мы можем использовать базовый тип - HTMLElement и применить значению этого типа css-класс темы, но результат работы нашей функции теряет специфичность. Мы не можем, например, использовать его в сцепке с другими методами.

```ts
interface ThemeMiddleware{
  (element: HTMLElement): HTMLElement
}
```

## Демонстрация проблемы

в файле [модульного теста](https://codesandbox.io/s/infallible-perlman-3dht9?file=/src/theme-middleware.test.ts) видно, что TypeScript теряет информацию о специфичности элемента.

Особенность нашей ситуации в том, что она существует только в TypeScript. Jest - исполняя результат JavaScript - никакой проблемы не видит. Jest-у хорошо.

Попробуем сделать так, чтобы и TypeScript нам помогал на этапе разработки.



