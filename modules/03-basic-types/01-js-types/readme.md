# Работа с примитивными типами

## Система типов javascript

Все типы данных, которые вы можете различать в javascript остаются в вашем распоряжении и при работе с typescript. Прежде всего это примитивные типы

* boolean
* number
* string
* undefined
* bigint (ES2020)

Все свойства, особенности и операции, характерные для этих типов в TypeScript идентичны тем что вам известно о них из javascript. В частности вы можете использовать оператор `typeof` для получения сведения о типе значения переменной.

```typescript
console.log(typeof true);// 'boolean';
console.log(typeof 42);// 'number';
console.log(typeof 'the one');// 'string';
console.log(typeof 1n);// 'bigint';
```

А теперь посмотрим как TypeScript вступает в работу. Вы можете открыть [в песочнице](https://www.typescriptlang.org/play?target=7#code/DYUwLgBARgrgZnEAnCBeCByDBuAUAYwHsA7AZ0gEMyB3ZNCAFgCY9YE71nsg) код и убедится в строгости компилятора. Он сообщит об ошибке.

```javascript
let buffer = '';
const answer = 42;
buffer = 42;// здесь будет ошибка!
```

Выражение `buffer = 42` совершенно законное для javascript вызывает ошибку `Type 'number' is not assignable to type 'string'.(2322)`. Дело в том, что мы использовали TypeScript но не сделали аннотации типов наших переменных. Компилятору приходится, рассматривая эти строки, неявно добавлять переменным аннотацию типов. Он это делает настолько хорошо, насколько он может угадать. Для компилятора следующие три строки эквивалентны предыдущим

```typescript
// Компилятор видит, что buffer-у присваивают строчку 
// и считает, что buffer будет всегда использован
// только для строк - неявно ставит :string как 
// аннотацию для типа значений допустимых 
// для переменной buffer
let buffer:string = ''; 
// Компилятор рассуждает аналогично случаю
// с переменной buffer
// 42 это числовое значение и компилятор 
// учитывает это неявной аннотацией тип :number
const answer:number = 42;
// Компилятор обнаруживает, что 
// в переменную buffer с аннотацией :string
// будет присвоено значение переменной answer
// т.е. числовое значение, но это недопустимо
// Вот и выдал ошибку.
buffer = 42; 
```

Как видно из описания ошибки, TypeScript считает, что переменная буфер предназначена только для работы со строками. В течение этого курса мы обсудим, как объяснить компилятору наши намерения хранить в буфере и строки и числа. Но уже из этого примера видно, что TypeScript требует от разработчика более внимательного и точного выражения намерений. 

Забегая вперед, и чтобы удовлетворить любопытство, посмотрим, как можно объяснить компилятору наши намерения.

```typescript
let buffer: string|number = '';
const answer = 42;
buffer = answer;
```

Мы добавили аннотацию типа `: string|number` (читается как переменная buffer типа строка или число получает начальное значение - пустая строка), мы объяснили компилятору, что в переменной buffer мы планируем хранить не только строки, но и числа.

Сделаем вывод, пока мы не смешиваем примитивные типы внутри одной переменной, TypeScript ведет себя практически идентично javascript.

## Знакомство с типами функции

Рассмотрим пример использования функции в typescript
```typescript
document.addEventListener('click',function(ev){console.log(ev);});
```
На первый взгляд функция `function(ev){console.log(ev);}` не выглядит так уж подозрительно, но это только благодаря умению TypeScript догадываться и подставлять аннотации типов неявным образом. Что написано в этом исходном тексте, можно представить так.
```typescript
document.addEventListener<"click">('click',function (this:Document, ev:MouseEvent):void {console.log(ev)});
```
Каждый элемент этого выражения мы разберем в свое время. Попробуйте [посмотреть в песочнице](https://www.typescriptlang.org/play?target=7#code/CYewxgrgtgpgdgFwHQENjAKIDd4IDICWAzgvDAE4A8ARGADYFgDW1AfABQDk9jTnANADMIcMAgIg4AAnYIAFsQBcAEXDRc-KTCyKAsiAhEY2XAEpFWEAWBSA3mElEQdGEjogA5u22mAvqYBuIA), какой код будет создан для javascript.

Сейчас важно запомнить, что обявляя функцию мы должне заявить о намерении использовать в качестве аргументов значения определенных типов. 

Для описания различных вариантов функций в TypeScript ввели дополнительные специальные типы.

* void - для функций которые делают какие-нибудь побочные эффекты, но ничего не возвращают.
* never - для функций которые никогда не возвращаются. Вообще. Бесконечный цикл или throw new Error

тип void предназначен для описания результата функции, которая ничего не возвращает. Если вы знакомы с C/C++, Java, то вам понятно использование этого типа. 

```typescript
function log(message:string):void{
    console.log(message);
}
```
В отличии от void тип never подсказывает компилятору и нам с вами, что функция никогда не возвращается. Как функция может не вернуться? К примеру, она продолжает выполнять бесконечный цикл пока не нажмут кнопку выключения питания. Вот два примера, которые позволяют почувствовать поведение функций с типом результата never.

```typescript
const readMessage = ()=>''; // пример функции извлекающей сообщение о текущей температуре
const processMessage = (mes:string)=>{}; //пример функции упаковывающей и отправляющей результаты наблюдения в удаленный центр

// функция бесконечного цикла, пока не нажмут reset
function eventLoop():never{
    while(true){
        const m = readMessage();
        processMessage(m);
    }
}

function alwaysThrow():never{
    throw new Error('Not implemented yet');
}
```

## Структуры типов. Интерфейсы, псевдонимы

Данные в программах TypeScript можно группировать по смыслу и назначению в структурные типы.

```typescript
const hero = {
    givenName: 'Илья',
    fathersName: 'Ильич',
    familyName: 'Обломов',
};
```
Для TypeScript hero не только имеет значение, но еще имеет и тип. 

**Важно** описание этого типа существует только для TypeScript и после окончания трансляции в javascript полностью исчезает. 

Однако мы можем пользоваться знанием этого типа в других частях программы. Для того чтобы объявить еще одну переменную, содержащую такие же поля, а главное заставить TypeScript проверить, что мы не ошиблись мы можем запомнить описание типа и обозначить это описание отдельным идентификатором.

```typescript
type Hero = typeof hero;
const supporting: Hero = {
    givenName: 'Андрей',
    fathersName: 'Иванович',
    familyName: 'Штольц',
};
```
Проделайте эксперимент в песочнице. Скопируйте определение константы hero и типа Hero. Затем начинает выписывать инициализацию константы supporting. Вы увидите, как редактор начинает вас поддерживать и подсказывать.

Обратите внимание! Мы можем обозначить описание типа несколько раз разными словами. Все эти описания исчезнут во время работы программы, а во время компиляции эти значения идентичны друг-другу.

```typescript
type Hero = typeof hero;
type FullName = typeof hero;
type AnotherAlias = Hero;
```

**Важно!** Структурные типы в TypeScript эквивалентны, если их поля попарно эквивалентны или имеют одинаковые примитивные типы. Порядок следования полей не существенный.

```typescript
type NameStructure = {
    givenName: string,
    familyName: string,
    fathersName: string,
}
```

Поскольку нам известно только имя кухарки Обломова, мы не сможем использовать ни один из этих псевдонимов для инициализации переменной. Попытка написать что-то вроде этого приведет к ошибке 

```typescript
const cook: NameStructure = { // 
    givenName: "Анисья"
}
```
*Type '{ givenName: string; }' is missing the following properties from type 'NameStructure': familyName, fathersName(2739)*

Мы уже убедились, что TypeScript требует точного выражения намерений в использовании типов. Ему надо заранее знать, что переменной будут присвоены значения и числовия и строковые. Так же он поступает и со структурными типами. Когда программисту требуется выразить намерение оставить некоторые поля без инициализации следует использовать специальный тип "undefined".

Мы можем использовать другое определение типа
```typescript
type Character = {
    givenName: string,
    familyName?: string | undefined,
    fathersName?: string | undefined,
}
const cook: Character = { // 
    givenName: "Анисья"
}
```

**Внимание!** В коде TypeScript вы можете встретить два разных undefined. В приведенном выше примере undefined обозначает специальный тип.

## Специальный тип unknown
В ходе работы программы вы можете получить значение, тип которого вам заренее неизвестен. Бэкенд вполне может вернуть вам что-то непонятное. Вы можете объяснить typescript-у, что вы действительно не знаете заранее тип значения, и TypeScript позаботится о том, чтобы вы не забыли проверить какие-нибудь признаки для определения типа значения.

```typescript
 const uv:unknown = 42; //значение полученное в ответ от api
 if(typeof uv === "number" && Number.isFinite(uv)){
     console.log(uv/2); //проверено, число!
 }
 if(typeof uv ==="string" && uv.length>0){
     console.log(uv[0]); //проверено, строка!
 }
```

В этом примере мы намеренно указали тип переменной `unknown` и продемонстрировали вариант опознавания реального типа. В следующих разделах мы познакомимся и с другими способами выяснить тип и произвести действия со значениями неизвестного типа.

