# Демо: использование утилитарных типов

TypeScript предоставляет множество полезных условных типов. Их применение не только сокращает время на выписывание структуры интерфейсов, но и добавляет смысловой контекст для разработчика.

В различных приложениях пользователь часто добавляет новые записи в базу данных. Это может быть бизнес, где добавляются новые заказы, или игра, где регистрируются рекорды. 

Часть сведений к записи добавляет сам сервер. Например, пользователь не должен указывать данные о дате получения заказа. Пусть это делает только центральный сервер. 

TypeScript позволяет разработчику создавать описания типов, удовлетворяющих таким требованиям. В частности Pick и Omit. В своей основе утилитарные Pick и Omit являются проекциями. Например, вы могли бы самостоятельно реализовать Pick:

```ts
type MyPick<T, K extends keyof T> = {
  [k in K]: T[k];
};
```

Но вам этого делать не придётся. В библиотеке типов TypeScript Pick и Omit уже подготовлены.

## Пример интерфейса и обсуждение вычисляемых полей

Мы обсудим использование утилитарных типов с целью донести до коллег сведения о происхождении типов. В прошлых демонстрациях, когда нужно было уменьшить количество полей в ожидаемом аргументе, мы определяли новый, ни с чем не связанный тип. Использование Pick и Omit позволяет не только изменить количество полей, но и показать связь между используемыми в приложениях типами.

По форме интерфейса [`Message`](https://codesandbox.io/s/jovial-breeze-4sxrb?file=/src/i-face-message.ts) пользователь может передавать и получать сведения о дате создания и прочтения сообщения. При создании нового сообщения пользователь заполняет не все поля. Приложение самостоятельно инициализирует идентификатор отправителя `from`, а поле `read` для отправляемого сообщения не является актуальным.

Представим работу приложения по обмену сообщениями. Реализовать хранение состояния такого приложения можно в рамках идеологии redux.

Кстати, redux содержит необходимые для TypeScript декларации внутри своего пакета npm.
