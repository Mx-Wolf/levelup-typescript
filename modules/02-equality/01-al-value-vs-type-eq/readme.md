# Параллельные пространства имён: декларации и типы

Приведённый ниже код — первоклассный код в TypeScript. Никаких проблем с пересечением имён не наблюдается.

```tsx
const Paths = ["/", "/bin", "/etc"];
type Paths = "/" | "/bin" | "/etc";

```

[Посмотреть в песочнице](https://www.typescriptlang.org/play?ssl=2&ssc=36&pln=1&pc=1#code/MYewdgzgLgBACgQygCwjAvDA2gIgPQ4A0+ARgJZhEz4CmUwOAugNwCwAUFAJ4AON8SVBmoEYAHxHlK4kXQZt2QA).

Следующий код не может похвастаться таким свойством. Компилятор «жалуется», что `Cannot redeclare block-scoped variable 'Paths'.`

```tsx
const Paths = ["/", "/bin", "/etc"];
class Paths {};
```

[Посмотреть в песочнице](https://www.typescriptlang.org/play?#code/MYewdgzgLgBACgQygCwjAvDA2gIgPQ4A0+ARgJZhEz4CmUwOAugNwCwAUMADYIRqIo0AbwC+zIA).

Приходится делать вывод, что `type Path` существует в какой-то другой, параллельной Вселенной — и это правда.

> **На заметку**: термин «Вселенная» в отношении типов используется в математике с середины 70-х годов XX века (Мартин-Леф, 1975 год). Очень интересная [теория](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%82%D0%B8%D0%BF%D0%BE%D0%B2).

В TypeScript используются три параллельных набора имён. Любая декларация — объявление имени — делает вклад как минимум в одно из этих трёх пространств:

* namespace,
* types,
* values.

Когда декларации относятся к разным Вселенным, они не мешают друг другу.

## Декларации и их Вселенные

Познакомьтесь с типичными представителями разных Вселенных.

|декларация | namespace | type | value |
|-----|----|----|----|
| `namespace` | Да | | Да |
| `class` |  | Да | Да |
| `enum`  |  | Да | Да |
| `interface` |  | Да | |
| `type` | | Да | |
| `function`| | | Да |
| `const`| | | Да |
| `let`| | | Да |

Таблица подтверждает, что переменные и типы обитают в разных Вселенных и не мешают друг другу.

## Типы

В этом курсе мы сосредоточим внимание на колонке **type**. Это значит, что целями нашего изучения будут типы, интерфейсы, перечисления и классы. При этом часть сведений о классах и перечислениях, важных для разработки и для разработчика, мы оставим на следующие курсы.

TypeScript использует структурную типизацию. Это значит, что типы, обладающие одинаковым внутренним устройством, считаются эквивалентными. Как это выглядит на практике, мы увидим в следующем параграфе.
