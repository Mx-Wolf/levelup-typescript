# Параллельные пространства имен - вселенные* типов и мир значений

Код приведенный ниже - первоклассный код в TypeScript. Никаких проблем с пересечением имен не наблюдается

```tsx
const Paths = ["/", "/bin", "/etc"];
type Paths = "/" | "/bin" | "/etc";

```

[Playground Link](https://www.typescriptlang.org/play?ssl=2&ssc=36&pln=1&pc=1#code/MYewdgzgLgBACgQygCwjAvDA2gIgPQ4A0+ARgJZhEz4CmUwOAugNwCwAUFAJ4AON8SVBmoEYAHxHlK4kXQZt2QA)

Однако, следующий код не может похвастаться таким свойством. Компилятор жалуется, что `Cannot redeclare block-scoped variable 'Paths'.`

```tsx
const Paths = ["/", "/bin", "/etc"];
class Paths {};
```

[Playground Link](https://www.typescriptlang.org/play?#code/MYewdgzgLgBACgQygCwjAvDA2gIgPQ4A0+ARgJZhEz4CmUwOAugNwCwAUMADYIRqIo0AbwC+zIA)

Приходится делать вывод, `type Path` существует в какой-то другой, параллельной вселенной. И это правда.

**На заметку** термин "вселенная" в отношении типов используется в математике с середины 70-х годов XX века (Martin-L¨of (1975)). Очень интересная теория, кстати. Но вернемся к TypeScript.

В TypeScript используется три параллельные набора имен. Любая декларация - объявление имени, - делает вклад, как минимум, в одно из этих трех пространств.

* namespace
* types
* values

Когда декларации относятся к разным вселенным, они не мешают друг другу.

## Декларации и их вселенные

Познакомьтесь с типичными представителями разных вселенных

|декларация | namespace | type | value |
|-----|----|----|----|
| `namespace` | Да | | Да |
| `class` |  | Да | Да |
| `enum`  |  | Да | Да |
| `interface` |  | Да | |
| `type` | | Да | |
| `function`| | | Да |
| `const`| | | Да |
| `let`| | | Да |

Таблица подтверждает, что переменные и типы обитают в разных вселенных и не мешают друг другу.

## Типы

В этом курсе мы сосредоточим внимание на колонке **type**. Это значит, что целями нашего изучения будут типы, интерфейсы, перечисления и классы. При этому часть сведений о классах и перечислениях, безусловно важных для разработки и для разработчика, мы оставим на следующие курсы.

TypeScript использует структурную типизацию. Это значит, что типы обладающие одинаковым внутренним устройством считаются эквивалентными. Как это выглядит на практике мы увидим в следующем параграфе.
