# Обобщение по отношению к типам типов

## Теория типов

Для наших целей тип это вывеска на коробке. На вывеске написано название типа, а внутри коробки лежат элемент - все возможные значения типа

* В коробке с названием *number* лежат значения, которые определены стандартом IEEE-754 (кроме Infinity, NaN)
* В коробке с названием *string* лежат строки. Их там бесконечно много.
* В коробке boolean - два элемента.
* и т.д.

## Операции с типами

Возьмем коробку побольше и объединим в ней содержимое наших *string* и *number*. Взболтаем и перемешаем.

Элемент, который мы можем вытащить из этой большой коробки может быть числом или строкой.

Коробка стала "шире", но чтобы поработать с каким либо значением из этой коробки сначала приходится уточнять что нам попалось на этот раз - число или строка.

**Внимание!** Чтобы описать объединение нескольких типов,  TypeScript  применяет оператор `|`. Синтаксис: `string | number`

Можно представить другую ситуацию. Нам нужны такие значения, которые одновременно находятся в двух или нескольких коробках. Множество таких значений пересечение исходных множеств доступных значений. Подумайте, результатом после вызова функции encounterFlyingDutchman будут не все жители Нидерландов, а только летучие голландцы.

```typescript
type Flying = {
    fly():void,
};
type Fish = {
  swim():void,
};
type Saucer = {
    holdJam():void;
}
type Dutchman = {
    moveToAmsterdam():void;
}

declare function getFlyingFish():Flying & Fish;
declare function detectFlyingSaucer(): Flying & Saucer;
declare function encounterFlyingDutchman(): Flying & Dutchman;

getFlyingFish().fly();
detectFlyingSaucer().fly();
encounterFlyingDutchman().moveToAmsterdam();
```

**Внимание** Если мы хотим потребовать от TypeScript такой новый тип, значения которого одновременно являются значениями нескольких других, мы используем синтаксис `string & number`.

* читайте `type n = a | b` как: новый тип значения которого являются либо значениями типа `a` либо значениями типа `b`
* читайте `type n = a & b` как: новый тип `n` такой, что любое значение этого типа является одновременно значение и типа `a` и типа `b`.

Как бы вы прочитали?

```typescript
type n = (string | number) & string;
```

## Порядок во вселенной типов

Мы уже говорили, что во вселенной типов можно выяснить отношения между типами. Для двух типов может случиться так, что одни расширяет другой. Выше мы составляли тип `string | number`, он шире, чем отдельно `string` или отдельно `number`. Если продолжать наводить порядок среди всего разнообразия типов, найдется ли тип, шире которого ничего нет? А как на счет самого узкого типа - уже которого не бывает? Можем ли мы построить что-то вроде оси координат?

```text
самый узкий < пошире < ... < еще пошире < ... < самый широкий
```

Оказывается что-то подобное можно построить.

## Единичные элементы системы типов

Помните, при сложении чисел есть такое специальное число 0. Его можно добавлять к любому другому числу, но "ничего не поменяется". При умножении есть другое специальное число 1. Эти числа еще называют - единичными элементами относительно операции сложения и операции умножения. У TypeScript есть две специальные коробки - их названия - unknown и  never.

тип unknown работает единичным элементом для операции пересечения

```typescript
  T & unknown => T
```

Коробка с именем unknown самая широкая, но зато на ней пустой список операций. Ничего мы не можем сделать с этим типом. Ну разве что `typeof` выяснить.

Тип never работает единичным элементом для операции объединения

```typescript
  T | never => T
```

Коробка с этим типом самая узкая - в ней нет никаких элементов. Немудрено, что с любым элементом (из нуля) элементов можно совершать любые операции. Такая уж математика.

![Система типов typescript](assets/type-system.png)

## Встречаем обобщенное программирование

Когда TypeScript гарантирует нам что со значениями того или иного типа можно делать оговоренные действия мы можем создавать процедуры, которые заранее не определяют конкретный тип. Обобщенное программирование эксплуатирует понятие совместимости типов.

Совместимость типов в TypeScript основана на структурной эквивалентности принятой в JavaScript. Этот подход отличает TypeScript от статически типизированных языков - Java, C# и других. В частности в TypeScript допускается использование следующей специализации

```typescript
type Dancer = {
  specialty: "ballet" | "acrobatic rock&roll" | "lindy hop"
}

let prime: Dancer;

const student = {
    specialty: "ballet",
    name: "Peppa Pig",
} as const;

prime = student;
```

Переменная `student` неявно получила класс с двумя ключами - specialty и name и по принципу структурности Javascript может быть использована в любом месте, где может быть использована переменная prime.

Вооруженные этим знанием мы можем создать первую обобщенную программу.

```typescript
// функция вернет первый элемент массива. 
// Его тип и значение будет известно потом. 
// сейчас важно, что набор элементов это массив
function firstItem<T>(array:T[]):T{
  if(array.length>0){
    return array[0];
  }
  throw new Error("empty array");
}
```

Слева от круглых скобок с аргументами функции мы написали выражение `<T>`. Эта запись уведомляет TypeScript о намерении использовать символ **T** в качестве псевдонима типа значений. В частности мы требуем, чтобы в качестве аргумента наша функция получала значение массива тех самых элементов типа **T**. Видите `array:T[]`? Вместо **T** можно подставить `string` или `number` или имя любого другого типа, работоспособность функции не нарушится.

Имея описание такой функции мы можем опереться на компилятор и поручить ему убедиться, что после получения элементы мы сможем использовать значения по назначению

```typescript
const array1 = [42,73];
// компилятор проделает логические рассуждения и сделает вывод
// что theAnswer будет иметь тип число.
const theAnswer = firstItem(array1);
// typeof theArray === "number";
// мы может использовать значение безопасно
Math.abs(theAnswer); //ok
theAnswer.split(","); //Property 'split' does not exist on type 'number'.(2339)

```

Возможности обобщенного программирования делают TypeScript очень мощным инструментом и мы регулярно  будет использовать их в работе.
