title: Тест по примитивным типам. Использование, преобразование, обнаружение
type: test
description: Повторим основные моменты, связанные с использованием примитивных типов.
wizard: true
questions:
  - id: 1
    title: "В каких операциях (из отрывка приведенного ниже) происходит явное преобразование типа значения?"
    description: |
      ```ts
      const a = (42 ===  '42' as string | number as number);
      const b = (42 ==  '42' as string | number as number);
      const c = (42 == new Number('42'));
      const d = (42 === new Number('42'));
      const e = (42 === Number('42'));
      ```
    type: single
    options:
      - id: 1
        value: (a) указание (as string | number as number) явно преобразует значение строки в число.
        correct: false
        resultMessage: |
          В TypeScript заказ типа `as` не является операцией run-time, не влечёт за собой никаких накладных расходов во время исполнения и не преобразует значение.
      - id: 2
        value: (b) для выполнения сравнения (42 ==  '42') строка преобразуется в число
        correct: false
        resultMessage: |
          TypeScript унаследовал примитивные типы от JavaScript, но при этом пытается помочь разработчику избежать дефектов. Разработчик может отказаться от этой помощи и использовать, например, нестрогое сравнение с неявным преобразованием типов. Мы не рекомендуем так делать.
      - id: 3
        value: (c) для выполнения сравнения объект типа Number преобразуется к типу number.
        correct: false
        resultMessage: |
          Оператор нестрогого сравнения выполняет неявное преобразование типа значения.
      - id: 4
        value: (d) для выполнения строгого сравнения разработчик прибегнул к явному преобразованию типов.
        correct: false
        resultMessage: |
          Оператор строго значения не производит преобразования типов значений.
      - id: 5
        value: (e) для выполнения строгого сравнения строка явно преобразуется в число.
        correct: true
        resultMessage: |
          Конструктор класса Number, когда используется как функция, без оператора new выполняет роль явного преобразования значения в числовое. Вы также можете использовать parseFloat или parseInt. Последняя функция более предпочтительна при работе с целыми числами, поскольку позволяет указать основание системы счисления.

  - id: 2
    title: "В чём отличие отрывка программы, если его читать как TypeScript или как JavaScript?"
    description: |
      ```ts
      const buffer = 'боль';
      buffer[0] = 'с';
      console.log(buffer);
      ```
    type: single
    options:
      - id: 1
        value: Компилятор TypeScript генерирует ошибку, JavaScript не исполняется.
        correct: false
        resultMessage: |
           Строка является примитивным типом, её значение изменить нельзя. TypeScript предупредит об ошибке, однако JavaScript исполняется, хотя и не приводит к изменению значения строки в переменной buffer.
      - id: 2
        value: Компилятор TypeScript генерирует ошибку, JavaScript исполняется, строка не изменяется.
        correct: true
        resultMessage: |
          Действительно, TypeScript постарается предупредить разработчика о некорректном использовании доступа по индексу. Однако JavaScript исполняет этот отрывок без ошибок и без изменения значения строки в переменной buffer.
      - id: 3
        value: Компилятор TypeScript допускает такой отрывок, JavaScript завершает работу с ошибкой.
        correct: false
        resultMessage: |
          TypeScript постарается предупредить разработчика о некорректном использовании операции доступа по индексу к символам строки и выдаст ошибку.
      - id: 4
        value: Компилятор TypeScript генерирует ошибку, JavaScript исполняется. На консоль выводится 'соль'.
        correct: false
        resultMessage: |
          Строка является примитивным типом и не поддается изменению через операции доступа по индексу.

  - id: 3
    title: "Выберите наиболее правильный тип значений, которые получат флаги из отрывка ниже."
    description: |
      ```ts
      const buffer = 'боль';
      buffer[0] = 'с';
      console.log(buffer);
      ```
    type: single
    options:
      - id: 1
        value: Оба флага получат значения типа boolean, поскольку перед присвоением производится логическая операция.
        correct: false
        resultMessage: |
          Операция логическое ИЛИ производит неявные преобразования типа с целью выполнения логических операций, но результатом этой операции является значение 'последнего вычисленного' операнда.
      - id: 2
        value: Оба флага — разные значения одного и того же 'сложного' типа.
        correct: false
        resultMessage: |
          Операция логическое ИЛИ производит неявные преобразования типа с целью выполнения логических операций, но результатом этой операции является значение 'последнего вычисленного' операнда. Последним вычисляется операнд, значение которого представляет значение true.
      - id: 3
        value: flag1 получит значение 42 — это значение тип number, flag2 получит значение 'zero-coding' — это значение строкового типа.
        correct: true
        resultMessage: |
          Определение факта принадлежности значения одному из примитивных типов — важный процесс, и вам придётся к нему прибегать довольно регулярно.
