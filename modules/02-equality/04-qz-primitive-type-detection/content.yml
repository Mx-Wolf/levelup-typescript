title: Примитивные типы. Использование, преобразование, обнаружение
type: test
wizard: true
questions:
  - id: 1
    title: "В каких операциях из приведённого ниже отрывка происходит явное преобразование типа значения?"
    description: |
      ```ts
      const a = (42 === '42' as string | number as number);
      const b = (42 == '42' as string | number as number);
      const c = (42 == new Number('42'));
      const d = (42 === new Number('42'));
      const e = (42 === Number('42'));
      ```
    type: single
    options:
      - id: 1
        value: (a) указание (as string | number as number) явно преобразует значение строки в число.
        correct: false
        resultMessage: |
          В TypeScript заказ типа `as` не является операцией run-time, не влечёт за собой никаких накладных расходов во время исполнения и не преобразует значение.
      - id: 2
        value: (b) для выполнения сравнения (42 == '42') строка преобразуется в число
        correct: false
        resultMessage: |
          TypeScript унаследовал примитивные типы от JavaScript, но при этом пытается помочь разработчику избежать ошибок. Разработчик может отказаться от этой помощи и использовать, например, нестрогое сравнение с неявным преобразованием типов. Мы не рекомендуем так делать.
      - id: 3
        value: (c) для выполнения сравнения объект типа Number преобразуется к типу number.
        correct: false
        resultMessage: |
          Оператор нестрогого сравнения выполняет неявное преобразование типа значения.
      - id: 4
        value: (d) для выполнения строгого сравнения разработчик прибегнул к явному преобразованию типов.
        correct: false
        resultMessage: |
          Оператор строго значения не производит преобразования типов значений.
      - id: 5
        value: (e) для выполнения строгого сравнения строка явно преобразуется в число.
        correct: true
        resultMessage: |
          Конструктор класса Number, когда используется как функция, без оператора new выполняет роль явного преобразования значения в числовое. Вы также можете использовать parseFloat или parseInt. Последняя функция более предпочтительна при работе с целыми числами, поскольку позволяет указать основание системы счисления.
  - id: 2
    title: "В чём отличие отрывка программы, если его читать как TypeScript или как JavaScript?"
    description: |
      ```ts
      const buffer = 'боль';
      buffer[0] = 'с';
      console.log(buffer);
      ```
    type: single
    options:
      - id: 1
        value: Компилятор TypeScript генерирует ошибку, JavaScript не исполняется.
        correct: false
        resultMessage: |
           Строка является примитивным типом, её значение изменить нельзя. TypeScript предупредит об ошибке, однако JavaScript исполняется, хотя и не приводит к изменению значения строки в переменной buffer.
      - id: 2
        value: Компилятор TypeScript генерирует ошибку, JavaScript исполняется, строка не изменяется.
        correct: true
        resultMessage: |
          Действительно, TypeScript постарается предупредить разработчика о некорректном использовании доступа по индексу. Однако JavaScript исполняет этот отрывок без ошибок и без изменения значения строки в переменной buffer.
      - id: 3
        value: Компилятор TypeScript допускает такой отрывок, JavaScript завершает работу с ошибкой.
        correct: false
        resultMessage: |
          TypeScript постарается предупредить разработчика о некорректном использовании операции доступа по индексу к символам строки и выдаст ошибку.
      - id: 4
        value: Компилятор TypeScript генерирует ошибку, JavaScript исполняется. На консоль выводится 'соль'.
        correct: false
        resultMessage: |
          Строка является примитивным типом и не поддаётся изменению через операции доступа по индексу.
  - id: 3
    title: "Выберите наиболее правильный тип значений, которые получат флаги из отрывка ниже."
    description: |
      ```ts
      const flag1 = (42 || 'Answer to Life, The Universe, and everything');
      const flag2 = (0  || 'zero-coding?');
      ```
    type: single
    options:
      - id: 1
        value: Оба флага получат значения типа boolean, поскольку перед присвоением производится логическая операция.
        correct: false
        resultMessage: |
          Операция логическое ИЛИ производит неявные преобразования типа с целью выполнения логических операций, но результатом этой операции является значение 'последнего вычисленного' операнда.
      - id: 2
        value: Оба флага — разные значения одного и того же 'сложного' типа.
        correct: false
        resultMessage: |
          Операция логическое ИЛИ производит неявные преобразования типа с целью выполнения логических операций, но результатом этой операции является значение 'последнего вычисленного' операнда. Последним вычисляется операнд, значение которого представляет значение true.
      - id: 3
        value: flag1 получит значение 42 — это значение тип number, flag2 получит значение 'zero-coding' — это значение строкового типа.
        correct: true
        resultMessage: |
          Определение факта принадлежности значения одному из примитивных типов — важный процесс, и вам придётся к нему прибегать довольно регулярно.
  - id: 4
    title: "Значение какой переменной относится к примитивному типу?"
    description: |
      ```ts
      const a = 42;
      const b = new Number(42);
      const c = Number(42);
      const d = Number('Life, the universe, everything');
      ```
    type: multiple
    options:
      - id: 1
        value: Значение переменной `a` имеет встроенный примитивный тип `number`.
        correct: true
        resultMessage: |
          Числовой литерал создаёт значение примитивного типа.
      - id: 2
        value: Значение переменной `b` имеет встроенный примитивный тип `Number`.
        correct: false
        resultMessage: |
          Оператор `new` создаёт экземпляр класса Number, который не является примитивным.
      - id: 3
        value: Значение переменной `c` имеет встроенный примитивный тип `number`.
        correct: true
        resultMessage: |
          Функция `Number`, вызванная без оператора `new`, возвращает числовое значение, которое является примитивным.
      - id: 4
        value: Значение переменной `d` имеет встроенный примитивный тип.
        correct: true
        resultMessage: |
          Функция `Number`, вызванная без оператора `new`, возвращает числовое значение, которое является примитивным. NaN — это числовое значение.
  - id: 5
    title: "Изменится ли значение примитивного типа?"
    description: |
      ```ts
      let primitiveValue = 42;
      primitiveValue += 1;
      ```
    type: single
    options:
      - id: 1
        value: Да, значение примитивного типа 42 станет равным 43.
        correct: false
        resultMessage: |
          Следует различать значение примитивного типа и значение переменной, которой оно присвоено. Значение переменной можно изменить, а значение примитивного типа изменить нельзя.
      - id: 2
        value: Нет, значение примитивного типа 42 так и останется значением 42.
        correct: true
        resultMessage: |
          Примитивные значения в JavaScript и в TypeScript неизменяемы. Следует различать значение примитивного типа и значение переменной, которой оно присвоено.
  - id: 6
    title: "TypeScript предоставляет оператор typeof. Он возвращает строку с названием типа значения, содержащегося в переменной. Этот оператор можно использовать, чтобы выяснить тип полученного параметра."
    description: |
      Сколько сравнений необходимо выполнить, чтобы уверенно выяснить, что значение является структурой? Для иллюстрации, в API браузера метод `addEventListener(type, listener, useCapture);` может принимать три параметра. Третий параметр, если присутствует, может быть примитивным значением или структурой. Нужно определить, что значение такого параметра — это не строка, не число и не флаг, а именно структура с полями (свойствами).
    type: multiple
    options:
      - id: 1
        value: |
          Это должен выяснить компилятор и сервисы TypeScript. Никаких дополнительных действий от разработчика не требуется.
        correct: false
        resultMessage: |
          Без сравнений не обойтись!
      - id: 2
        value: |
          Достаточно выяснить значение оператора typeof.
        correct: false
        resultMessage: |
          Если вы решили обойтись одним сравнением, вероятно, это `typeof useCapture === 'object'`. Однако этого недостаточно. Дело в том, что выражение `typeof null` тоже возвращает значение `'object'`.
      - id: 3
        value: |
          Следует проверить значение оператора `typeof` и сравнить значение с `null`.
        correct: true
        resultMessage: |
          Структурное значение переменной `value` будет иметь `typeof value ===\"object\"`, но не должно быть `value === null`, поэтому необходимо и достаточно выяснить, что выражение `typeof value ===\"object\" && value !== null` вычисляется в `true`.
      - id: 4
        value: Необходимо проверить, что значение задано, сравнить результат оператора `typeof` с 'object' и проверить значение на равенство 'null'.
        correct: false
        resultMessage: |
          Если вы решили произвести больше двух сравнений, обратите внимание, что значение переменной `value` будет иметь `typeof value ===\"object\"`, но не должно быть `value === null`, поэтому необходимо и достаточно выяснить, что выражение `typeof value ===\"object\" && value !== null` вычисляется в `true.`
