# Внутренняя структура типа и есть тип

Данные в программах TypeScript можно группировать по смыслу и назначению в структурные типы.

```typescript
const hero = {
    givenName: 'Илья',
    fathersName: 'Ильич',
    familyName: 'Обломов',
};
```

Для TypeScript hero не только имеет значение, но еще имеет и тип.

**Важно** описание этого типа существует только для TypeScript и после окончания трансляции в javascript полностью исчезает.

Однако мы можем пользоваться знанием этого типа в других частях программы. Для того чтобы объявить еще одну переменную, содержащую такие же поля, а главное заставить TypeScript проверить, что мы не ошиблись мы можем запомнить описание типа и обозначить это описание отдельным идентификатором.

```typescript
type Hero = typeof hero;
const supporting: Hero = {
    givenName: 'Андрей',
    fathersName: 'Иванович',
    familyName: 'Штольц',
};
```

Проделайте эксперимент в песочнице. Скопируйте определение константы hero и типа Hero. Затем начинает выписывать инициализацию константы supporting. Вы увидите, как редактор начинает вас поддерживать и подсказывать.

Обратите внимание! Мы можем обозначить описание типа несколько раз разными словами. Все эти описания исчезнут во время работы программы, а во время компиляции эти значения идентичны друг-другу.

```typescript
type Hero = typeof hero;
type FullName = typeof hero;
type AnotherAlias = Hero;
```

**Важно!** Структурные типы в TypeScript эквивалентны, если их поля попарно эквивалентны или имеют одинаковые примитивные типы. Порядок следования полей не существенный.

```typescript
type NameStructure = {
    givenName: string,
    familyName: string,
    fathersName: string,
}
```

Поскольку нам известно только имя кухарки Обломова, мы не сможем использовать ни один из этих псевдонимов для инициализации переменной. Попытка написать что-то вроде этого приведет к ошибке

```typescript
const cook: NameStructure = { // 
    givenName: "Анисья"
}
```

**Сообщение**: *Type '{ givenName: string; }' is missing the following properties from type 'NameStructure': familyName, fathersName(2739)*

Мы уже убедились, что TypeScript требует точного выражения намерений в использовании типов. Ему надо заранее знать, что переменной будут присвоены значения и числовые и строковые. Так же он поступает и со структурными типами. Когда программисту требуется выразить намерение оставить некоторые поля без инициализации следует использовать специальный тип "undefined".

Мы можем использовать другое определение типа

```typescript

type Character = {
    givenName: string,
    familyName?: string | undefined,
    fathersName?: string | undefined,
}
const cook: Character = { // 
    givenName: "Анисья"
}
```

**Внимание!** В коде TypeScript вы можете встретить два разных undefined. Первый *undefined*, как и в JavaScript, - это значение неинициализированной переменной. В этом случае ключевое слово undefined живет в пространстве значений. Вы можете присвоить значение `undefined` переменной или свойству объекта. Второй **undefined** живет в пространстве типов. Это тоже ключевое слово, но оно обозначает тип возможного значения переменной. В приведенном выше примере **undefined** обозначает специальный тип.

Попробуйте прочитать запись о типе следующим образом.

> значения типа Character могут ( см. наличие вопросительного знака '?') иметь свойство `fathersName`. При этом если свойство присутствует его значение может быть либо строкой либо оставаться неинициализированным.

Вот такой абзац сдержится в короткой записи `fathersName?: string | undefined`

## Специальный тип unknown

В ходе работы программы вы можете получить значение, тип которого вам заранее неизвестен. Удаленный сервис вполне может вернуть вам что-то непонятное. Вы можете объяснить typescript-у, что вы действительно не знаете заранее тип значения, и TypeScript позаботится о том, чтобы вы не забыли проверить какие-нибудь признаки для определения типа значения.

```typescript
 const uv:unknown = 42; //значение полученное в ответ от api
 if(typeof uv === "number" && Number.isFinite(uv)){
     console.log(uv/2); //проверено, число!
 }
 if(typeof uv ==="string" && uv.length>0){
     console.log(uv[0]); //проверено, строка!
 }
```

В этом примере мы намеренно указали тип переменной `unknown` и продемонстрировали вариант опознавания реального типа. В следующих разделах мы познакомимся и с другими способами выяснить тип и произвести действия со значениями неизвестного типа.
