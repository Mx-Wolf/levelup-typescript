# Внутренняя структура типа

Данные в программах TypeScript можно группировать по смыслу и назначению в структурные типы.

```typescript
const hero = {
    givenName: 'Илья',
    fathersName: 'Ильич',
    familyName: 'Обломов',
};
```

В этом примере для TypeScript `hero` имеет не только имеет значение, но ещё и тип.

**Важно** описание этого типа существует только для TypeScript и после окончания трансляции в JS полностью исчезает.

Мы можем использовать знание этого типа и в других частях программы. Чтобы объявить ещё одну переменную, содержащую такие же поля, а главное, заставить TypeScript проверить, что мы не ошиблись, мы можем запомнить описание типа и обозначить это описание отдельным идентификатором.

```typescript
type Hero = typeof hero;
const supporting: Hero = {
    givenName: 'Андрей',
    fathersName: 'Иванович',
    familyName: 'Штольц',
};
```

Выполните эксперимент в песочнице. Скопируйте определение константы `hero` и типа `Hero`. Затем начинайте выписывать инициализацию константы `supporting`. Вы увидите, как редактор начинает вас поддерживать и подсказывать.

Обратите внимание, мы можем обозначить описание типа несколько раз разными словами. Все описания исчезнут во время работы программы, а во время компиляции эти значения будут идентичны друг другу.

```typescript
type Hero = typeof hero;
type FullName = typeof hero;
type AnotherAlias = Hero;
```

**Важно:** структурные типы в TypeScript эквивалентны, если их поля попарно эквивалентны или имеют одинаковые примитивные типы. Порядок следования полей несущественный.

```typescript
type NameStructure = {
    givenName: string,
    familyName: string,
    fathersName: string,
}
```

Посмотрим следующий пример. Поскольку нам известно только имя кухарки Обломова, мы не сможем использовать ни один из этих псевдонимов для инициализации переменной. Попытка написать что-то вроде этого приведёт к ошибке:

```typescript
const cook: NameStructure = { // 
    givenName: "Анисья"
}
```

**Сообщение**: *Type '{ givenName: string; }' is missing the following properties from type 'NameStructure': familyName, fathersName(2739)*.

Мы уже убедились, что TypeScript требует точного выражения намерений в использовании типов. Ему надо заранее знать, что переменной будут присвоены значения и числовые, и строковые. Так же он поступает и со структурными типами. Когда программисту нужно оставить некоторые поля без инициализации, следует использовать специальный тип *undefined*.

Мы можем использовать другое определение типа:

```typescript

type Character = {
    givenName: string,
    familyName?: string | undefined,
    fathersName?: string | undefined,
}
const cook: Character = { // 
    givenName: "Анисья"
}
```

В коде TypeScript можно встретить два разных undefined. Первый *undefined*, как и в JavaScript, — это значение неинициализированной переменной. В этом случае ключевое слово undefined живёт в пространстве значений, вы можете присвоить это значение переменной или свойству объекта. Второй **undefined** живёт в пространстве типов. Это тоже ключевое слово, но оно обозначает тип возможного значения переменной. В приведённом выше примере **undefined** обозначает специальный тип.

Попробуйте прочитать запись о типе следующим образом.

> Значения типа Character могут (смотрим наличие вопросительного знака '?') иметь свойство `fathersName`. При этом, если свойство присутствует, его значение может быть либо строкой, либо оставаться неинициализированным.

Вот такой абзац сдержится в короткой записи `fathersName?: string | undefined`.

## Специальный тип unknown

При работе программы вы можете получить значение, тип которого вам заранее неизвестен. Удалённый сервис может вернуть вам что-то непонятное. В таких случаях вы можете объяснить TypeScript, что не знаете заранее тип значения. И тогда TypeScript позаботится о том, чтобы вы не забыли проверить какие-нибудь признаки для определения типа значения.

```typescript
 const uv:unknown = 42; //значение, полученное в ответ от API
 if(typeof uv === "number" && Number.isFinite(uv)){
     console.log(uv/2); //проверено, число!
 }
 if(typeof uv ==="string" && uv.length>0){
     console.log(uv[0]); //проверено, строка!
 }
```

В этом примере мы намеренно указали тип переменной `unknown` и продемонстрировали вариант опознавания реального типа. В следующих разделах мы познакомимся и с другими способами выяснить тип и произвести действия со значениями неизвестного типа.
