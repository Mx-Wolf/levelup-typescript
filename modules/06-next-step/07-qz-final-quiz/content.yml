title: "Typescript. Теория типов"
type: test
wizard: true
description: "Мы собрали для вас вопросы, которые часто попадаются на собеседованиях в различных компаниях."
questions:
  - title: "Какие из перечисленных типов являются примитивными в TypeScript?"
    description: "bigint\n      boolean\n      Date\n      Map\n      never\n      null\n      number\n      Set\n      string\n      symbol\n      undefined\n      unknown"
    type: multiple
    id: 1
    options:
      - correct: true
        value: "bigint."
        resultMessage: "Примитивный тип JavaScript."
        id: 1
      - correct: true
        value: "boolean."
        resultMessage: "Примитивный тип JavaScript."
        id: 2
      - correct: true
        value: "null."
        resultMessage: "Примитивный тип JavaScript."
        id: 3
      - correct: true
        value: "number."
        resultMessage: "Примитивный тип JavaScript."
        id: 4
      - correct: true
        value: "string."
        resultMessage: "Примитивный тип JavaScript."
        id: 5
      - correct: true
        value: "symbol."
        resultMessage: "Примитивный тип JavaScript."
        id: 6
      - correct: true
        value: "undefined."
        resultMessage: "Примитивный тип JavaScript."
        id: 7
      - correct: false
        value: "Date."
        resultMessage: "Встроенный тип JavaScript, является объектом."
        id: 8
      - correct: false
        value: "Map."
        resultMessage: "Встроенный тип JavaScript, является объектом."
        id: 9
      - correct: false
        value: "Set."
        resultMessage: "Встроенный тип JavaScript, является объектом."
        id: 10
      - correct: true
        value: "never."
        resultMessage: "TypeScript дополняет набор примитивных типов в целях анализа."
        id: 11
      - correct: true
        value: "unknown."
        resultMessage: "TypeScript дополняет набор примитивных типов в целях анализа."
        id: 12
  - title: "Как объявить переменную, значением которой может быть массив, содержащий элементы строковых или числовых значений?"
    type: single
    id: 2
    options:
      - value: "Добавить аннотацию типа `let fruits: string[];`."
        correct: false
        resultMessage: "Массив с аннотацией `string[]` может содержать только строки в качестве значений элементов."
        id: 1
      - value: "Использовать обобщённый тип. `let fruits: Array<string>;`."
        correct: false
        resultMessage: "Переменная с типом Array<string> может содержать значение — массив, элементами которого могут быть только строки."
        id: 2
      - correct: false
        value: "Использовать способность компилятора догададываться о разрешённых типах по контексту: let arr = [1, 3, 'Apple', 'Orange', 'Banana', true, false];."
        resultMessage: "TypeScript способен выяснить тип переменной по контексту использования. Поскольку в массиве представлены и числа, и строки, и флаги, TypeScript обозначит переменную arr типом (string | number | boolean)[]."
        id: 3
      - correct: true
        value: "Добавить переменной аннотацию — массив объединения типа: `let values: (string | number)[];`."
        resultMessage: "Можно объявить переменную массива и сообщить о возможности сохранения в качестве элементов значения различных типов"
        id: 4
  - title: "В каких случаях не требуется аннотация типа при объявлении переменной?"
    type: multiple
    id: 3
    options:
      - correct: true
        value: "let x = 3;"
        resultMessage: "Тип переменной — number."
        id: 1
      - correct: true
        value: "let x = [0, 1, null];"
        resultMessage: "number|null — выбирается наилучший общий тип."
        id: 2
      - correct: true
        value: "window.onmousedown = function (mouseEvent) {}"
        resultMessage: "Тип переменной mouseEvent определяется по контексту типа обработчика."
        id: 3
      - correct: true
        value: "const Header = ():Item =>[new Home(),new About(), new Profile()];"
        resultMessage: "Тип элементов массива Item — при условии, что все классы являются наследниками Item."
        id: 4
  - title: "Какие ошибки обнаружит компилятор при сборке приведённой программы при компиляции с флагом strict?"
    description:  |
      ```ts\ntype
      Action = ()=>void;\n
      const getItem:Action = () =>{\n
      return 42;\n
      }\n
      const item = getItem();\n
      console.log(item);\n
      \n```
    type: single
    id: 4
    options:
      - correct: true
        value: "Не обнаружит никаких ошибок."
        resultMessage: "Функцию, возвращающую результат, можно использовать на месте, где ожидается  функция, возвращающая void."
        id: 1
      - correct: false
        value: "Type 'number' is not assignable to type 'void'."
        resultMessage: ""
        id: 2
  - title: "Какие значение программа отобразит в консоли?"
    type: single
    id: 5
    description: "```ts\ntype Action = ()=>void;\n      const getItem:Action = () =>{\n          return 42;\n      }\n      const item = getItem();\n      console.log(item);\n      \n```"
    options:
      - correct: false
        value: "Не отобразит никаких символов."
        resultMessage: "в JavaScript все функции возвращают значения, даже если это undefined."
        id: 1
      - correct: true
        value: "42."
        resultMessage: "в JavaScript все функции возвращают значения, даже если это undefined."
        id: 2
  - title: "Допускает ли TypeScript следующую программу?"
    description: |
      ```ts
      type TextProvider = ()=>string;
      const THRESHOLD = 0.5;
      const getText:TextProvider =()=>{
        try{
          if(Math.random()<THRESHOLD){
            return 'success';
          }
          throw new Error('failure');
        }
        catch(err){
          return err.message;
        }
      }
      ```
    type: single
    id: 6
    options:
      - correct: false
        value: "Компилятор соберёт программу и создаст JS-файл без каких-либо предупреждений."
        resultMessage: "Компилятор, в зависимости от настроек флагов, может выдать предупреждение о возможном отсутствии свойства message. TypeScript не предусматривает аннотацию значения переменной в выражении catch."
        id: 1
      - correct: false
        value: "Компилятор выдаст предупреждение об отсутствии аннотации типа переменной err."
        resultMessage: "Компилятор, в зависимости от настроек флагов, может выдать предупреждение о возможном отсутствии свойства message. TypeScript не предусматривает аннотацию значения переменной в выражении catch."
        id: 2
  - title: "Какие флаги компилятора создадут условия для безошибочной компиляции программы?"
    description: |
      ```ts
      const THRESHOLD = 0.5;
      type TextProvider = ()=>string;
      const getText:TextProvider =()=>{
        try{
          if(Math.random()<THRESHOLD){
            return 'success';
          }
          throw 'failure';
        }
        catch(err){
          return err.message;
        }
      }
      ```
    type: single
    id: 7
    options:
      - correct: false
        value: "Программа синтаксически неверна, она не будет компилироваться без ошибок."
        resultMessage: "JavaScript позволяет использовать в выражении throw значение любого типа."
        id: 1
      - correct: true
        value: "useUnknownInCatchVariables=false."
        resultMessage: "Этот флаг заставляет компилятор считать все значения переменных в выражениях catch имеющими тип any."
        id: 2
  - title: "Сколько ошибок обнаружит компилятор?"
    description: |
      ```ts
      const optimist = ()=>true;
      let typeofValue: string;

      typeofValue = typeof true;
      typeofValue = typeof ()=>true;
      typeofValue = typeof (()=>true);
      typeofValue = typeof optimist;
      ```
    type: single
    id: 8
    options:
      - correct: false
        value: "0."
        resultMessage: "TypeScript специально ограничивает возможность использования оператора typeof в отношении выражения, которое можно спутать с вызовом функции."
        id: 1
      - correct: false
        value: "1."
        resultMessage: "TypeScript специально ограничивает возможность использования оператора typeof в отношении выражения, которое можно спутать с вызовом функции."
        id: 2
      - correct: true
        value: "2."
        resultMessage: "TypeScript специально ограничивает возможность использования оператора typeof в отношении выражения, которое можно спутать с вызовом функции."
        id: 3
  - title: "Какие варианты для настройки компилятора возможны при работе c TypeScript?"
    type: multiple
    id: 9
    options:
      - correct: true
        value: "Создание tsconfig.json в корневой директории проекта."
        resultMessage: ""
        id: 1
      - correct: true
        value: "Запуск tsc с набором параметров в командной строке."
        resultMessage: ""
        id: 2
      - correct: true
        value: "Настройки в проекте msbuild, например, .csproj."
        resultMessage: ""
        id: 3
  - title: "Сколько реализаций придётся создать для трёх вариантов перегруженных функций?"
    description:  |
     ```ts
     declare function date(ticks:number):Date;
     declare function date(year:number, month: number, day:number):Date;
     declare function date(isoString:string):Date;
     ```
    type: single
    id: 10
    options:
      - correct: false
        value: "Три различные реализации."
        resultMessage: "TypeScript выбирает вариант объявления функции в порядке объявления и требует только одной реализации. Объявление самой реализации недоступно во время анализа."
        id: 1
      - correct: false
        value: "Реализация набора таких функций невозможна."
        resultMessage: "TypeScript выбирает вариант объявления функции в порядке объявления и требует только одной реализации. Объявление самой реализации недоступно во время анализа."
        id: 2
      - correct: true
        value: "Требуется одна реализация."
        resultMessage: "TypeScript выбирает вариант объявления функции в порядке объявления и требует только одной реализации. Объявление самой реализации недоступно во время анализа."
        id: 3
  - title: "Какую нагрузку несут в TypeScript интерфейсы?"
    type: multiple
    id: 11
    options:
      - correct: true
        value: "Определяют контракт между компонентами программы."
        resultMessage: ""
        id: 1
      - correct: true
        value: "Предоставляют возможности для реализации полиморфизма."
        resultMessage: ""
        id: 2
      - correct: false
        value: "Исключают множественное наследование."
        resultMessage: "TypeScript позволяет при описании интерфейсов расширять один или несколько интерфейсов-родителей."
        id: 3
      - correct: true
        value: "определяют имя для нового типа данных."
        resultMessage: ""
        id: 4
      - correct: false
        value: "Добавляют свойство в объект import.meta."
        resultMessage: ""
        id: 5
  - title: "Приведённая программа компилируется без ошибок. Будет ли компилятор считать программу ошибочной, если заменить Pick<ServiceBase,\"queryData\"> на ServiceBase?"
    description: |
      ```ts
      class ServiceBase{
        private endpoint:string = '';
        protected getQueryUrl(endpoint:string):string{return endpoint};
        public async queryData():Promise<unknown>{
          const response = await fetch(this.getQueryUrl(this.endpoint));
          if(response.ok){
            return await response.json();
          }
          throw new Error();
        }
      }

      const mockService:Pick<ServiceBase,"queryData"> = {
        queryData:()=>Promise.resolve({})
      }
      ```
    type: single
    id: 12
    options:
      - value: "Разработчик может использовать имя класса на месте, где ожидается имя типа, поэтому программа будет компилироваться без ошибок."
        correct: false
        resultMessage: "Компилятор попытается обеспечить наличие private и protected полей мокового значения и не сможет выполнить этого. Программа не будет компилироваться, ошибка: 'Type '{ queryData: () => Promise<{}>; }' is missing the following properties from type 'ServiceBase': endpoint, getQueryUrl'."
        id: 1
      - value: "Разработчик не сможет использовать описание типа значений экземпляров класса ServiceBase для создания моковых значений."
        correct: true
        resultMessage: "Компилятор попытается обеспечить наличие private и protected полей мокового значения и не сможет выполнить этого. Программа не будет компилироваться, ошибка: 'Type '{ queryData: () => Promise<{}>; }' is missing the following properties from type 'ServiceBase': endpoint, getQueryUrl'."
        id: 2
  - title: "На примере приведённой программы объясните, что означает объединение типов в TypeScript?"
    description: "```ts\ntype KeyFieldType = number |string;\n\n      const keyToFind:KeyFieldType = 42;\n      const findKey = (keyToFind:KeyFieldType):KeyFieldType => keyToFind;\n      const keyFound: number = findKey();\n```"
    type: single
    id: 13
    options:
      - correct: true
        value: "Переменной объединённого типа можно присвоить значение любого из объединяемых типов."
        resultMessage: ""
        id: 1
      - correct: false
        value: "Переменной любого из объединяемых типов можно присвоить значение объединённого типа."
        resultMessage: "Объединяемые типы могут иметь несовместимые свойства."
        id: 2
  - title: "На примере приведённой программы объясните, что означает пересечение типов в TypeScript."
    description:  |
      ```ts\nconst example = <TLeft, TRight>(keyToFind: TLeft & TRight, prefix:TLeft) => {\n
      type KeyFieldType = TLeft&TRight;\n
      keyFound = prefix;\n
      const findKey = (keyToFind: KeyFieldType): KeyFieldType => keyToFind;\n
      const keyFound: TLeft = findKey(keyToFind);\n
      return keyFound;\n
      }\n```
    type: single
    id: 14
    options:
      - correct: false
        value: "Переменной пересечённого типа можно присвоить значения любого из пересекаемых типов."
        resultMessage: "Значения в пересекаемом типе могут выходить за рамки пересечения."
        id: 1
      - correct: true
        value: "Переменной любого из пересекаемых типов можно присвоить значение пересеченного типа."
        resultMessage: "Значения в пересекаемом типе могут выходить за рамки пересечения."
        id: 2
  - title: "В контексте определения кортежа из трёх элементов определите, сколько ошибок обнаружит компилятор для программы."
    description:   |
      ```ts\ntype ShoppingCartLine = [label: string, price: number, discont: number];\n
      const prepareLine = (\n
      label: string,\n
      price: number,\n
      discont?: number,\n
      ): ShoppingCartLine => discont ? [label, price, discont] : [label, price];\n
      \n```
    type: single
    id: 15
    options:
      - correct: false
        value: "0."
        resultMessage: "Все элементы должны быть инициализированы при создании кортежа."
        id: 1
      - correct: true
        value: "1."
        resultMessage: "Все элементы должны быть инициализированы при создании кортежа."
        id: 2
      - correct: false
        value: "2."
        resultMessage: "Все элементы должны быть инициализированы при создании кортежа."
        id: 3
  - description: "```ts\ntype ShoppingCartLine = [label: string, price?: number, discont: number];\n  const prepareLine = (\n      label: string,\n      price: number,\n      discont?: number,\n  ): ShoppingCartLine => discont ? [label, price, discont] : [label, price];\n  \n```"
    options:
      - correct: true
        value: "0."
        resultMessage: "TypeScript допускает необязательные элементы в хвосте кортежа."
        id: 1
      - correct: false
        value: "1."
        resultMessage: "TypeScript допускает необязательные элементы в хвосте кортежа."
        id: 2
      - correct: false
        value: "2."
        resultMessage: "TypeScript допускает необязательные элементы в хвосте кортежа."
        id: 3
    title: "В контексте определения кортежа из трёх элементов определите, сколько ошибок обнаружит компилятор для программы."
    type: "single"
    id: 16
  - description: "```ts\nconst buffer: unknown = 'TypeScript' as unknown\nconst len: number = (buffer as string).length;\n```"
    options:
      - correct: false
        value: "0."
        resultMessage: "TypeScript допускает необязательные элементы только в хвосте кортежа."
        id: 1
      - correct: false
        value: "1."
        resultMessage: "TypeScript допускает необязательные элементы только в хвосте кортежа."
        id: 2
      - correct: true
        value: "2."
        resultMessage: "TypeScript допускает необязательные элементы только в хвосте кортежа."
        id: 3
    title: "В контексте определения кортежа из трёх элементов определите, сколько ошибок обнаружит компилятор для программы."
    type: "single"
    id: 17
  - title: "На примере приведённой программы выясните, создаёт ли дополнительную нагрузку на сборщик мусора использование утверждения типа (as)."
    description:   |
      ```ts\nconst buffer: unknown = 'TypeScript' as unknown\nconst len: number = (buffer as string).length;\n```
    type: single
    id: 18
    options:
      - value: "Нет, утверждение типа не создаст дополнительной нагрузки на сборщик мусора."
        correct: true
        resultMessage: "В отличие от других языков программирования, утверждение типа (as) не влечёт за собой каких-либо действий во время исполнения. Эти утверждения используются только во время компиляции."
        id: 1
      - value: "Да, утверждение типа создаст временное значение, которое придётся утилизировать сборщику мусора."
        correct: false
        resultMessage: "В отличие от других языков программирования, утверждение типа (as) не влечёт за собой каких-либо действий во время исполнения. Эти утверждения используются только во время компиляции."
        id: 2
  - title: "Что делает флаг компилятора strictNullChecks?"
    type: multiple
    id: 19
    options:
      - correct: false
        value: "Запрещает использование ключевого слова null."
        resultMessage: "Когда этот флаг — false, компилятор TypeScript игнорирует null и undefined. Если этот флаг — true, значения null и undefined получают свои собственные особенные типы."
        id: 1
      - correct: true
        value: "Добавляет специальный тип undefined в набор примитивных типов."
        resultMessage: "Когда этот флаг — false, компилятор TypeScript игнорирует null и undefined. Если этот флаг — true, значения null и undefined получают свои собственные особенные типы."
        id: 2
      - correct: true
        value: "Предотвращает доступ к несуществующим свойствам объекта."
        resultMessage: "Когда этот флаг — false, компилятор TypeScript игнорирует null и undefined. Если этот флаг — true, значения null и undefined получают свои собственные особенные типы."
        id: 3
      - correct: false
        value: "Контролирует использование типа any в программе."
        resultMessage: "Когда этот флаг — false, компилятор TypeScript игнорирует null и undefined. Если этот флаг — true, значения null и undefined получают свои собственные особенные типы."
        id: 4
  - title: "Что делает флаг компилятора noImplicitAny?"
    type: "single"
    id: 20
    options:
      - correct: false
        value: "Запрещает использование ключевого слова any для обозначения типа."
        resultMessage: "В некоторых случаях, при отсутствии аннотации типа TypeScript, не сумев определить тип по контексту будет считать переменную содержащей значение типа any. Наличие указанного флага в такой ситуации заставляет компилятор сообщать об ошибке."
        id: 1
      - correct: true
        value: "Требует, чтобы компилятор сообщил о значениях, тип которых он не может определить по контексту."
        resultMessage: "В некоторых случаях, при отсутствии аннотации типа TypeScript, не сумев определить тип по контексту будет считать переменную содержащей значение типа any, наличие указанного флага в такой ситуации заставляет компилятор сообщать об ошибке"
        id: 2
  - title: "Какой результат выполнения программы вы ожидаете?"
    description:   |
      ```ts\nconst item = 'TypeScript';\n
      const result = `expression ${item}`;\n
      type item = 'TypeScript';\n
      type result = `expression ${item}`;\n
      \n
      const expression:result = result;\n
      console.log(expression);\n```
    type: single
    id: 21
    options:
      - correct: false
        value: "Программа не компилируется. Её нельзя запустить."
        resultMessage: "Компилятор сообщит об ошибке, но создаст JavaScript-исходник. Результатом работы программы будет строка на консоли [LOG]: \"expression TypeScript\"."
        id: 1
      - correct: false
        value: "Typescript сообщит об ошибке, но создаст программу. Эта программа завершится с ошибкой."
        resultMessage: "Компилятор сообщит об ошибке, но создаст JavaScript-исходник. Результатом работы программы будет строка на консоли [LOG]: \"expression TypeScript\"."
        id: 2
      - correct: true
        value: "TypeScript сообщит об ошибке, но создаст программу. Эта программа при запуске выведет на экран сообщение."
        resultMessage: "Компилятор сообщит об ошибке, но создаст JavaScript-исходник. результатом работы программы будет строка на консоли [LOG]: \"expression TypeScript\"."
        id: 3
  - title: "Какой тип ожидается у переменной buffer?"
    description:   |
      ```ts\ntype SpellOutNumber<T> = T extends number? string: T;\n\n
      declare function spell<T>(value:T):SpellOutNumber<T> ;\n
      \n
      const buffer = spell(Date());\n
      \n```
    type: single
    id: 22
    options:
      - correct: false
        value: "Date."
        resultMessage: "Тип переменной будет string, благодаря вычислениям условного типа SpellOutNumber."
        id: 1
      - correct: false
        value: "number"
        resultMessage: "Тип переменной будет string, благодаря вычислениям условного типа SpellOutNumber."
        id: 2
      - correct: true
        value: "string"
        resultMessage: "Тип переменной будет string, благодаря вычислениям условного типа SpellOutNumber."
        id: 3
  - title: "Определение типа StrictType эквивалентно какому предоставленному типу?"
    description:  |
      ```ts
      type StrictType<T>={
        [K in keyof T]-?:T[K]|undefined
      }

      interface PersonalData{
        name:string;
        passport: string;
        driversLicense?: string | undefined;
      }

      declare function getPersonalData():PersonalData;
      const data:StrictType<PersonalData> = getPersonalData();
      ```
    type: single
    id: 23
    options:
      - correct: false
        value: "Omit."
        resultMessage: "Приведённый тип создаёт проекцию тип-параметра, и все свойства теряют опциональность. Следовательно, он эквивалентен утилитарному типу Required."
        id: 1
      - correct: false
        value: "Partial."
        resultMessage: "Приведённый тип создаёт проекцию тип-параметра, и все свойства теряют опциональность. Следовательно, он эквивалентен утилитарному типу Required."
        id: 2
      - correct: false
        value: "Pick."
        resultMessage: "Приведённый тип создаёт проекцию тип-параметра, и все свойства теряют опциональность. Следовательно, он эквивалентен утилитарному типу Required."
        id: 3
      - correct: false
        value: "Readonly."
        resultMessage: "Приведённый тип создаёт проекцию тип-параметра, и все свойства теряют опциональность. Следовательно, он эквивалентен утилитарному типу Required."
        id: 4
      - correct: true
        value: "Required."
        resultMessage: "Приведённый тип создаёт проекцию тип-параметра, и все свойства теряют опциональность. Следовательно, он эквивалентен утилитарному типу Required."
        id: 5
